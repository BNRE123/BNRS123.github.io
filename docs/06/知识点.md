

## 一.Spring&Springboot

### 1.spring的事务隔离级别

- Spring的事务隔离级别其实是基于数据库的,Spring并没有自己的一套隔离级别

- DEFAULT:使用数据库的默认隔离界别

- READ_UNCOMMITTED：读未提交,最低的隔离级别,会读取到其他事务还未提交的内容，存在脏读

- REPEATABLE_READ：读已提交,读取到的内容都是已经可以提交的,可以解决脏读,但是存在不可重复读

- READ_COMMITTED：可重复读,在一个事务中多次读取时，看到相同而内容,可以解决不可重复读但是存在幻读

- SERIALIZABLE：串行化,最高的隔离级别,对于同一行记录,写会加锁,读回家所.在这种情况下,只有读读能并发执行,其他的并行的读写,写读,写写操作都是冲突,需要串行执行。可以防止脏读,不可重复读,幻读,没有并发事务问题

  **拓展**

  - 脏读:脏读就是指一个事务正在访问数据,并且对数据进行了修改,而这种修改还没有提交到数据库中,这时另外一个事物也访问并使用了这个数据
  
  - 不可重复读:在一个事务内,多次读取同一个数据.在这个事务还没有结束时,另外一个事务对该数据进行了修改,导致第一个事务读取到的数据不一致的情况,成为不可重复读(即同一事务未结束的情况下读取过的发生了修改).
  
### 2.spring的事务传播行为

### 3.什么是IOC

- 基本概念
  - IOC(Inverse Of Controll,控制反转)：就是原来代码里面需要自己手动创建的对象，依赖，反转给Spring来帮忙实现。我们需要创建一个容器，同时需要一种描述来让容器知道要创建的对象与对象之间的关系。
  - 在Spring中BeanFactory就是IOC容器，在Spring初始化的时候，创建容器，并将需要创建对象和对象的关系（xml，注解）通过BeanDefinitionReader加载到BeanDefinition中并保存在BeanDefinitionMap中，然后再由IOC容器创建bean对象.
- 两种bean的注册方式
  - 方法1：通过@Bean+@Configuration的方式直接定义要创建的对象与对象的关系
  - 方式2：通过@Component定义类，这种方式必须使用@ComponetScan定位Bean扫描路径

### 4.AOP

(从概念,实现,作用)

- AOP

  在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口采用 JDK 动态代理，如果是类采用CGLIB 方式实现动态代理。

- 相关概念

  - Joinpoint(连接点)：就是方法

  - Pointcut(切入点)：就是挖掉共性功能的方法

  - Advice(通知)：就是共性功能，最终以一个方法的形式呈现

  - Aspect(切面)：就是共性功能与挖的位置的对应关系

  - Target(目标对象)：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的

  - 提供的右下方Weaving(织入)：就是将挖掉的功能回填的动态过程

  - Proxy(代理)：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现

  - Introduction(引入/引介) ：就是对原始对象无中生有的添加成员变量或成员方法

- 实现

  1）获取增强器，例如被 Aspect 注解修饰的类。

  2）在创建每⼀个 bean 时，会检查是否有增强器能应⽤于这个 bean，简单理解就是该 bean 是否在该增强器指定的 execution 表达式中。如果是，则将增强器作为拦截器参数，使⽤动态代理创建bean 的代理对象实例。

  3）当我们调⽤被增强过的 bean 时，就会⾛到代理类中，从⽽可以触发增强器，本质跟拦截器类似。

### 5.spring的三级缓存

[参考](https://blog.csdn.net/ywl470812087/article/details/128494079)

### 6.spring bean的生命周期

​	1，Bean的实例化：spring启动后，会查找和加载需要被spring管理的Bean，并且实例化。
​	2，Bean属性注入：Bean被例化后对将Bean的引入和值注入到Bean的属性中。
​	3，调用BeanNameAware的setBeanName()方法：如果实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法。
​	4，调用BeanFactoryAware的setBeanFactory()方法：如果Bean实现了BeanFactoryAware接口的话，spring就将调用他们的setBeanFactory()方法，将BeanFactory容器实例传入。
​	5，调用ApplicationContextAware的setApplicationContext方法：如果Bean实现了ApplicationContextAware接口的话，spring将调用Bean的setApplicationContext方法，将Bean所在用用上下文引用传入进来。
​	6，调用BeanPostProcessor的预初始化方法：如果Bean实现了BeanPostProcessor接口，spring将调用他们的postProcessBeforeInitialization()方法。
​	7，调用InitializingBean的afterPropertiesSet()方法：如果Bean实现了InitializingBean接口，spring将调用他们的afterPropertiesSet()方法，类似的，如果Bean使用init-method生命了初始化方法的话，这个方法也会被调用。
​	8，调用BeanPostProcessor的初始化后的方法：如果Bean实现了BeanPostProcessor接口，spring就将调用他们的postprocessAfterInitialization()方法。
​	9，Bean可以使用了：这个时候，Bean就已经准备好了，可以被应用程序使用了，他们将一直驻留在应用的上下文中，直到应用的上下文被销毁。
​	10，调用DisposableBean的destory()方法：如果Bean实现DisposableBean接口，spring将用他的destory()就扣方法，相同的，如果Bean使用了destory-method生命销毁方法，该方法也会被调用。

### 7.如何理解WebSerice的restful风格

### 8.RequestBody和RequestParam的区别

### 9.Spring事务的实现

try catch(抛出异常),aop,threadlocal(获取相同的sql连接)三方面

### 10.Spring事务失效的场景

### 11.请说明spring mvc的运行机制和流程

springmvc是基于servlet的前端控制框架,核⼼是ioc和aop(基于spring实现) 核⼼架构的具体流程步骤如下： 

1、⾸先⽤⼾发送请求⸺>DispatcherServlet，前端控制器收到请求后⾃⼰不进⾏处理，⽽是委托给 其他的解析器进⾏ 处理，作为统⼀访问点，进⾏全局的流程控制；

 2、DispatcherServlet⸺>HandlerMapping， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含⼀个Handler 处理器（⻚⾯控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略； 

3、DispatcherServlet⸺>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从⽽⽀ 持多种类型的处理器，即适配器设计模式的应⽤，从⽽很容易⽀持很多类型的处理器； 

4、HandlerAdapter⸺>处理器功能处理⽅法的调⽤，HandlerAdapter 将会根据适配的结果调⽤真 正的处理器的功能处 理⽅法，完成功能处理；并返回⼀个ModelAndView 对象（包含模型数据、逻辑视图名）； 

5、ModelAndView的逻辑视图名⸺> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的 View，通过这种策 略模式，很容易更换其他视图技术；

 6、View⸺>渲染，View会根据传进来的Model模型数据进⾏渲染，此处的Model实际是⼀个Map数 据结构，因此 很容易⽀持其他视图技术；

 7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给⽤⼾，到此⼀个流程结束 

IOC控制反转的实现是基于spring的bean⼯⼚,通过获取要创建的类的class全限定名称,反射创建对象

dispatchservlet->handlermaping(映射为handlerExcutionChain)

### 12.servlet和controller的区别

### 13.Java实现动态主要涉及哪几个类以及实现步骤

[参考](https://blog.51cto.com/u_11315052/3711470)

### 14.IOC容器的创建过程

在Spring中BeanFactory就是IOC容器，在Spring初始化的时候，创建容器，并且将需要创建对象和对象的关系（xml，注解）通过BeanDefinitionReader加载到BeanDefinition中并且以键值对的形式保存在beanDefinitionMap中，然后再由IOC容器创建bean对象。

### 15.Json类型数据转换

### 16.单例模式(Spring用的哪种)

​	[参考](https://blog.csdn.net/qq_26012495/article/details/103128668)

- 单例模式

  保证一个类只有一个实例,并且在全局提供一个访问点.。

  在项目中,每次引用xml配置文件,就需要实例化一个Java Bean,但实际上我们全程只需要实例化一个,多出调用即可,而且配置文件可能还会越来越多,此时运用单例模式就可以减少资源的占用。

- 饿汉式

  

- DCL懒汉模式解决并发问题

- 懒汉式

  ```java
  //一开始没有实例化对象,而是需要用到的时候才去实例化,懒加载,时间换空间
  
  ```

- 枚举式

- 容器式(spring)

### 17.@RequestParam

- 主要是接收表单类型key value的参数

- 使用

  ```java
  
  public String editItem(@RequestParam(value="item_id",required=true) String id) {
  }
  //需要指定value名称
  /*1. spring在获取参数名称的时候无需通过asm获取字节码反射得到参数名称,速度更快.
  2. 不写参数名称openFegin调用会报错*/
  ```

### 18.springboot 自定义 starter

### 19.rollback,fallback,callback的区别

**callback的意思是回调：**一般用于异步任务取回结果。
**fallback意思是切换备用计划：**(备用计划可以是返回之前的状态，也可以是切换到备用机，也可以是plan B)。
**rollback意思是返回原来的状态：**(即没更新前的可用稳定状态)。

### 20.spring mvc和springboot的区别

​	

### 21.[BeanPostProcessor](https://blog.csdn.net/qq_46127735/article/details/111034714)

该接口我们也叫后置处理器，作用是在Bean对象在实例化和[依赖注入](https://so.csdn.net/so/search?q=依赖注入&spm=1001.2101.3001.7020)完毕后，在显示调用初始化方法的前后添加我们自己的逻辑。

### 22.Spring IOC的构建

1. 获取一个新的bean工厂:通常是ApplicationContext
2. 加载和解析spring的配置,解析bean对象,将解析到的bean封装成Bean
3. 实例化和调用BeanFactoryPostProcessor(BeanDefinitionRegistryProcessor)的扩展方法(这是一个非常重要的扩展点)
4. 实例化BeanPostProcessor,加载到BeanFactory中,但是这边还不能触发，改拓展接口的方法在bean对象执行初始化方法齐纳后背触发(这是另外一个重要的扩展点)
5. 实例化所有剩余的bean实例(非懒加载),包括:创建bean实例,bean实例属性填充,bean实例的初始化
6. 完成容器刷新,推送上下文刷新完毕事件(ContextRefreshedEvent)到监听器

### 23.事务失效场景

- 事务方法访问修饰符非public，导致事务失效

- @Transactional注解的方法抛出的异常不是spring的事务支持的异常，导致事务失效

- 数据表本身是不支持事务，导致事务失效(使用的是MyISAM引擎)

- 方法自身（this）调用问题，导致事务失效

  非事务方法insert()中调用的自身类的事务方法insertUser()。

- @Transactional注解所在的类没有被spring管理，导致事务失效

- 传播类型不支持事务，导致事务失效

- 多线程调用，导致事务失效

  [参考](https://blog.csdn.net/m0_67391120/article/details/126041740)

### 24.spring mvc常用的组件

- 核心控制器(DispatcherServlet)
- 映射处理器(HandlerMapping)
- 处理适配器(HandlerAdapter)
- 处理器(Handler)
- 视图解析器(ViewResolver)
- 拦截器(InterecptorHandler)
- 多媒体解析处理器

## 二.中间件

## 二.一redis

### 1.使用redis的优点

### 2.redis为什么那么快

redis快的原因主要取决于三方面

- 网络

- CPU

- 内存

### 3.redis重载锁

[参考](http://t.zoukankan.com/jelly12345-p-14493928.html)

### 4.redis死锁

### 5.redisson十五问

[参考](https://zhuanlan.zhihu.com/p/524874329)

### 6.redis分布式锁为什么是ap，zk分布式锁为什么是cp，zk的cp是强一致性吗

[redis ap](https://blog.csdn.net/woaitingting1985/article/details/115169812)

[zk cp](https://blog.csdn.net/u014297175/article/details/119944207)

[zk cp](https://cdn.modb.pro/db/212826)

### 6.什么是redis，redis有哪些特点？redis有哪些常见的应用场景

- Redis（Remote Dictionary Server）是一个开源的高性能键值存储系统，也被称为数据结构服务器。它支持多种类型的数据结构，如字符串、哈希、列表、集合、有序集合等，并提供了丰富的操作这些数据结构的命令。

  

  Redis的特点包括：

  1. 高性能：Redis使用内存来存储数据，并且数据存储在单一的进程中，因此速度非常快。
  2. 多样的数据类型：Redis支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等。
  3. 持久化：Redis支持多种持久化方式，包括RDB快照和AOF日志。
  4. 分布式：Redis支持分布式部署，可以将数据分布在多个节点上。
  5. 简单易用：Redis提供了丰富的命令，使得操作数据非常方便。

  

  Redis的常见应用场景包括：

  1. 缓存：Redis可以作为缓存使用，加速数据读取和响应速度。
  2. 消息队列：Redis提供了列表和发布/订阅功能，可以用来实现消息队列。
  3. 计数器：Redis的计数器功能非常高效，可以用来实现页面访问量、点击量等的计数。
  4. 排行榜：Redis的有序集合功能可以用来实现排行榜。
  5. 分布式锁：Redis可以用来实现分布式锁，保证多个进程之间的互斥访问。
  6. 实时数据分析：Redis可以作为实时数据分析的缓存层，加速数据分析速度。

  

  总之，Redis具有高性能、多样的数据类型、分布式、简单易用等特点，可以应用于各种场景，特别适合用来解决读写频繁的问题。

### 7.缓存雪崩,穿透,击穿及解决

* 缓存雪崩：是指在某一个时间段，缓存集中过期失效。导致数据库被击穿

* 解决方案

  * \* 给不同的Key的TTL添加随机值（不太受控制）

    \* 利用Redis集群提高服务的可用性（硬件开销大）

    \* 给缓存业务添加降级限流策略（用户体验一般）

    \* 给业务添加多级缓存（Nginx缓存 + JVM缓存 + Redis缓存）

* 缓存穿透：大量请求访问一个不存在的value，导致所有的请求都需要通过数据库进行查询

* 解决方案

  - 设置一个短时间的空值
  - 解决方案2：使用布隆过滤器

    * 布隆过滤器是根据一种特殊的hash算法存储key值，所以需要存储空间很少
    * **布隆过滤器可以判断某个数据一定不存在，但是无法判断一定存在**

* 缓存击穿：当海量请求访问一个key，这个key突然过期了，那么在这个一瞬间，所以的请求，就达到数据库中

* 解决方案

  * 使用分布式锁来阻塞读取数据的并发的问题(会出现阻塞问题)
  * 使用逻辑过期进行判断

### 8.Redis实现分布式锁

[参考](https://blog.csdn.net/weixin_46129192/article/details/126010250)

### 9.LRU和LFU算法的实现原理

### 10.redis与数据库的缓存一致性

## 二.二mq

### 1.削峰和限流的区别

### 2.保证消息的顺序消费

[参考](https://cloud.tencent.com/developer/article/2141503)

## 三.集合

### 1.hashmap底层实现

### 2.ArrayList和LinkedList的区别

### 3.CurrenHashMap的实现原理

## 四.JVM & 多线程

### 1.线程的创建方式

1. 继承Thread类,重写run方法

2. 实现Runable接口,实现run方法

   ```java
   //两种创建方式
   Thread thread = new Thread(new Runnable() {
               @Override
               public void run() {
                   System.out.println("I am a runnable task");
               }
           });
           thread.start();
   class RunnableTask implements Runnable {
       @Override
       public void run() {
           System.out.println("I am a runnable task");
       }
   }
   //main方法
   RunnableTask runnableTask = new RunnableTask();
   Thread thread1 = new Thread(runnableTask);
   thread1.start();
   //作为线程任务交给线程池,通过线程池维护的工作者线程来执行
   ExecutorService executor = Executors.newCachedThreadPool();
           RunnableTask runnableTask = new RunnableTask();
           executor.execute(runnableTask);
           executor.shutdown();
   ```

3. 实现Callable接口,实现call方法,该方法可以获取线程的执行结果

   [参考](https://blog.csdn.net/weixin_46760166/article/details/126928510)

### 2.Runnable和Callable的区别和联系

- 区别

  1. Runnable提供run方法，无法通过throws抛出异常，所有CheckedException必须在run方法内部处理。Callable提供call方法，直接抛出Exception异常。

  2. Runnable的run方法无返回值，Callable的call方法提供返回值用来表示任务运行的结果

  3. Runnable可以作为Thread构造器的参数，通过开启新的线程来执行，也可以通过线程池来执行。而Callable只能通过线程池执行。

     注意:Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！

- 补充Executor

### 3.volatile

[参考](https://blog.csdn.net/xueping_wu/article/details/124541419)

### 4.线程池的实现原理

[参考](https://blog.csdn.net/qq_36628536/article/details/110386468)

### 5.springcloud为什么不使用Executor线程池

[参考](https://blog.51cto.com/u_13294304/2970085)

### 6.线程池满了阻塞队列怎么办

[参考](https://baijiahao.baidu.com/s?id=1683884632939795855&wfr=spider&for=pc)

### 7.为什么会产生并发

不同的人操作同一块内存空间,即不同的请求会请求到同一块数据

### 8.ThreadLocal为什么可以解决一部分并发问题

### 9.线程池的核心属性

### 10.wait和sleep的区别(会不会释放锁)

[参考](https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=sleep%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E5%90%97&oq=aop%25E5%258A%25A8%25E6%2580%2581%25E4%25BB%25A3%25E7%2590%2586%25E7%259A%2584%25E4%25BD%259C%25E7%2594%25A8&rsv_pq=e07143e700000dc0&rsv_t=a41d%2Fye0JWDvFFpZMLnyBx3TcOJL61SfE7xoYy23o4kATFsAFig1W1efk2A&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_btype=t&inputT=8342&rsv_sug3=54&rsv_sug1=40&rsv_sug7=100&rsv_sug2=1&prefixsug=sleep%25E4%25BC%259A&rsp=0&rsv_sug4=9173)

### 11.自定义死锁

```java
public void transfer(Account from, Account to, int amt) {
        synchronized (from) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        //System.out.println("有这条语句就不会锁死，只有跳出同步锁代码块才能释放锁");
        
        synchronized (to) {
            if (from.withdraw(amt))
                to.deposit(amt);
            System.out.println("success");
        }
    }

```

### 12.OOM问题快速线上定位 &Java服务CPU100%问题快速定位

- OOM产生的原因(工具为jmap)

  1. 一次性申请对象太多

  2. 内存资源耗尽未释放

  3. 本身内存资源不够

     [参考](https://blog.csdn.net/weixin_40924043/article/details/123629978)

- Java服务CPU 100%

  - 场景

    假设，服务器上部署了若干Java站点服务，以及若干Java微服务，突然收到运维的CPU异常告警。如何定位是**哪个服务进程**导致CPU过载，**哪个线程**导致CPU过载，**哪段代码**导致CPU过载

  - 简要步骤(工具为top)

    1. 找到最耗CPU的进程；
    2. 找到最耗CPU的线程；
    3. 查看堆栈，定位线程在干嘛，定位对应代码；

### 13.JUC包

- **概念**

  java.util.concurrent （缩写 JUC）[并发](https://so.csdn.net/so/search?q=并发&spm=1001.2101.3001.7020)编程包是专门为 Java 并发编程设计的

- **JUC包内容结构**

  ![img](img/JUC.png)

  1. 锁（locks）部分：提供适合各类场合的锁工具；

  2. 原子变量（atomic）部分：原子变量类相关，是构建非阻塞算法的基础；

  3. 并发框架（executor）部分：提供线程池相关类型；

  4. 并发容器（collections） 部分：提供一系列并发容器相关类型；

  5. 同步工具（tools）部分：提供相对独立，且场景丰富的各类同步工具，如信号量、闭锁、栅栏等功能；

     - Semaphore(信号量):

       信号量通常用来限制线程可以同时访问的（物理或逻辑）资源数量。

     - CountDownLacth(闭锁):

       一种非常简单、但很常用的同步辅助类。其作用是在完成一组正在其他线程中执行的操作之前,允许一个或多个线程一直阻塞

     - CyclicBarrier(栅栏):

       一种可重置的多路同步点，在某些并发编程场景很有用。它允许一组线程互相等待，直到到达某个公共的屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier在释放等待线程后可以重用，所以称它为循环的barrier。

     - Phaser:

       一种可重用的同步屏障，功能上类似于CyclicBarrier和CountDownLatch，但使用上更为灵活。非常适用于在多线程环境下同步协调分阶段计算任务（Fork/Join框架中的子任务之间需同步时，优先使用Phaser）

     - Exchanger:

       允许两个线程在某个汇合点交换对象，在某些管道设计时比较有用。Exchanger提供了一个同步点，在这个同步点，一对线程可以交换数据。每个线程通过exchange()方法的入口提供数据给他的伙伴线程，并接收他的伙伴线程提供的数据并返回。当两个线程通过Exchanger交换了对象，这个交换对于两个线程来说都是安全的。Exchanger可以认为是 SynchronousQueue 的双向形式，在运用到遗传算法和管道设计的应用中比较有用。

### 14.lock和synchronized区别

### 15.JMM的内存类型

[参考](https://blog.csdn.net/LYQ20010417/article/details/124138635)

### 16.CAS

### 17.synchronized的锁升级

[参考](https://blog.csdn.net/weixin_45794641/article/details/123255683)

## 五.设计模式

## 六.java基础

### 1.反射

### 2.string stringbuffer stringbuilder

### 3.并行和并发

- 并发是指一个处理器在同一时间(分成多个时间点)处理多个程序，也就是说在同一时间一个处理器处理多个任务；
- 并行是指吗每一个CPU运行一个程序，也就是说多个处理器在同一时间处理多个一个任务

### 4.重载和重写

### 5.什么是双亲委派原则

### 6.Java8特性

### 7.常见关键字

- final

  修饰成员变量和类,以及修饰成员方法(被final修饰的变量,又被称为 自定义常量)

  - final关键字修饰类：则该类会成为最终类,即该类不能被继承(但是可以有父类);
  - final修饰成员变量：该成员变量必须在其所在类对象创建之前被初始化(且只能被初始化一次)
  - final修饰引用(静态代码块里面的变量)：该引用的值在实例不可以再改变
  - final修饰方法：该方法将不可以被重写，若试图重写父类方法,则会报错。不过该方法已然可以继承给子类(private修饰的方法会隐式的被指定为final方法)

  [参考](https://blog.csdn.net/weixin_47803347/article/details/117308393)

- static

  修饰变量,方法,静态,代码块

  - 静态变量：静态变量被所有的对象所共享,在内存中只有一个副本,他当且仅当在类初次加载的时候会被初始化.

  - 修饰成员方法：将其变成类方法,可以直接使用**类名.方法名**的方式进行调用.常用于工具类.

  - 代码块：将多个类成员放在一起初始化,是的程序更加规整,其中理解对象的初始化过程非常关键.

  [参考](https://www.cnblogs.com/yuteng666/p/14960430.html)

- tranisent

  transient是java语言的关键字,用来表示一个成员变量(特殊的数据成员,如：用户的密码,银行卡号)不是该对象序列化的一部分.当一个对象被序列化的时候,transient型变量的值不包括在序列化的结果中(序列化之后无法被访问).而非transient型的变量是被包括进去的。注意static修饰的静态变量天然就是不可序列化的.

  [参考](https://blog.csdn.net/u012723673/article/details/80699029)

- volatile

  - 概念：java虚拟机提供的轻量级同步机制

  - 作用：1.保证线程可见性;2.禁止指令重排.

  - 应用场景：多个线程读,一个线程写的场合

  [参考](https://blog.csdn.net/clinginh/article/details/115416672)

- synchronized

  - 同步锁

  - 作用：保证在同一时刻,被修饰的代码块或方法只会有一个线程执行,以达到并发安全的效果。

    原子性：确保线程互斥的访问同步代码

    可见性：保证共享变量的修改能够及时可见

    有序性：有序解决重排序问题(即"一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作")

    [参考](https://blog.csdn.net/m0_53474063/article/details/112389756)

### 8.final和volatile的区别                                                                                                                                                                                                                                                                                                                                                                                                                                    

- 是否可以修改值

  对于final来说,修饰的引用，方法和类都是"不可以改变的",而static修饰则可以修饰"改变"

- 何时加载

  对于final修饰的引用,方法来说,会在每一次实例化对象时加载,而static修饰则会在类加载时就加在且只加载一次,优先与对象存在

  [参考](https://blog.csdn.net/weixin_47803347/article/details/117308393)

### 9.String.intern()方法

**String.intern()方法是一种手动将字符串加入常量池中的native方法**，原理如下：如果在当前类的常量池中存在与调用intern()方法的字符串等值的字符串，就直接返回常量池中相应字符串的引用，否则在常量池中复制一份该字符串（Jdk7中会直接在常量池中保存当前字符串的引用），并将其引用返回；因此，只要是堆中等值的String对象，使用intern()方法返回的都是常量池中同一个String引用，所以，这些等值的String对象通过intern()后使用==是可以匹配的。

```java
String s3 = new String("1") + new String("1"); //常量池生成一个"1"，堆生成一个"11"
                                               //s3指向堆中"11"
                                       //中间还有2个匿名的new String("1")暂不讨论
s3.intern();             //因为常量池中不存在"11"，
                         //jdk6会将堆中"11"复制到常量池中，
                         //jdk7则将堆中"11"的引用添加到常量池中，
                         //此时s3仍指向堆中"11"
String s4 = "11";        //因为常量池中已存在"11"或其引用，s4指向常量池中"11"
System.out.println(s3==s4);  //jdk6中，s4指向常量池中"11"，s3指向堆中"11"，false
                             //jdk7中，s4指向常量池中指向堆中"11"的引用，true
```

[参考](https://blog.csdn.net/tianyuzui6/article/details/124417267)

### 10."=="和equals 最大的区别是

- "=="是运算符，如果是基本数据类型，则比较**存储的值**；如果是引用数据类型，则比较**所指向对象的地址值**。
- equals是Object的方法，比较的是**所指向的对象的地址值**，一般情况下，重写之后比较的是**对象的值**。

### 11.传值和传引用的区别

### 12.list，map，set的区别

- List：有序、可重复。
- Set：无序、不可重复的集合。重复元素会覆盖掉。
- Map：键值对，键唯一、值不唯一。Map 集合中存储的是键值对，键不能重复，值可以重复。

### 13.封装，继承，多态

- 封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

- 继承：子类继承父类，可以使用使用父类的所有功能，并在无需重新编写父类的情况下对这些功能进行扩展。

- 多态：指一个类实例的相同方法在不同情形有不同的表现方式(存在的条件：继承，重写，父类引用指向子类对象)。

### 14.重载和重写的区别

- 重载：允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
- 重写：在子类中定义的一个方法，其名称、返回类型及参数列表正好与父类中某个方法的名称、返回类型及参数列表相匹配，那么可以说，子类的方法重写了父类的方法。

### 16.JDK，JVM，JRE各自的含义以及区别

三者的联系是JDK包含JRE和JVM，JRE包含JVM

- JDK：JDK是Java开发的工具包，主要包含一下三方面的内容
  1. Java程序的运行环境-JRE
  2. Java的基础类库(Java API)
  3. Java的开发工具（其中包含了javac源码编译器，还有一些其他的命令：jdb，javah，jmp等）。
- JRE：JRE的Java程序的运行环境，所有的Java程序都必须依赖JRE才能运行，JRE=JVM+一些核心类库(lib目录下的文件)
- JVM：jvm是一个虚拟的中间平台，只负责将编译后的字节码文件转换成当前计算机能理解并执行的指令，其他都不关心。jvm是java"**一次编译，到处执行**”的原因。

### 15.Java的String类基本方法的介绍

### 16.什么是字节码?采用字节码的最大好处是什么？

- 字节码：编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的[机器码](https://so.csdn.net/so/search?q=机器码&spm=1001.2101.3001.7020)执行。在Java中，**这种供虚拟机理解的代码叫做 字节码（即扩展名为 .class的文件），它不面向任何特定的处理器，只面向虚拟机。**

- 好处：

  一次编译，多处运行。
  Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

### 17.Java，C++，Go语言的区别以及各自的优缺点

- JAVA

- - 优点

  - - 简单易学，代码可读性强
    - 跨平台，一次编写可以在多个操作系统上运行
    - 面向对象，支持继承、多态等特性
    - 丰富的类库，可以快速开发应用程序
    - 自动内存管理，减少了内存泄漏的可能性

  - 缺点:

  - - 由于JVM的存在，运行速度相对较慢
    - 对于实时性要求较高的场景，Java的表现可能不如C++和Go

- C++

- - 优点：

  - - 速度快，适合编写需要高性能的应用程序
    - 应用广泛，特别是在游戏开发、操作系统和嵌入式系统开发方面
    - 灵活性高，可以直接访问硬件和内存

  - 缺点：

  - - 学习难度较高，需要掌握指针、内存管理等底层知识
    - 容易出现内存泄漏和指针错误等问题
    - 编写代码过程中需要更多的手动管理，相比Java更容易出错

- Go:

- - 优点：

  - - 高并发，天生支持协程，能够轻松编写高效的并发程序
    - 简单易学，语法简洁，上手容易
    - 静态类型语言，可以避免一些潜在的运行时错误
    - 快速编译，可以快速构建和部署应用程序

  - 缺点：

  - - 缺乏丰富的类库，与Java和C++相比有些不足
    - 在一些性能要求极高的场景中可能不如C++表现
    - 语言本身还比较年轻，相关生态和工具还需要进一步完善

使用场景：

- **JAVA**

- - 适合开发企业级应用程序、后端服务等。

- C++

- - 适合开发需要高性能和高可靠性的应用程序，特别是在游戏开发、操作系统和嵌入式系统开发方面。

- GO

- - 适合开发高并发的后端服务、微服务、容器化应用程序等.

### 18.final和static的区别

- 修饰成员变量
  - final：final修饰的成员变量只能被赋值一次，赋值后不能再改变
  - static：被static修饰的成员变量独立于该类的任何对象，static修饰的变量可以被复制多次
- 修饰类
  - final：final修饰的类不可以被继承，没有子类，final类中的方法默认是final的
  - static类也不能被继承，可以不用初始化而访问
- 修饰方法
  - final：final修饰的方法不能被子类重写，但可以被继承，final也不能用来修饰构造方法(private不能被子类方法覆盖，private类型的方法默认是final类型的)
  - static：static方法可以被继承，但是不能重写，可以直接通过类调用

### 19.抽象类和接口的区别

- 抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板（如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）。
- 接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。（里面一般只定义方法，而且这个方法没有任何实现细节。换句话说，接口只定义它应该做什么。）

### 20.面向对象的理解

- 理解(概括)

  面向对象注**重参与一件事情里有多少个对象，并且分别需要做什么**。并且我们说到面向对象就会说到面向过程，面向过程是两种不同处理问题的角度，面向过程**更注重事情的每一个步骤**。

- 举个例子，比如说我要用热水壶煮茶：

          面向过程时——打开水壶——给水壶装水——放入茶叶——加热/煮——水沸腾进入保温——倒出；
          
          而面对象则是：人——打开水壶、装水、放入茶叶、倒出
          
                       水壶——进行加热、沸腾后自动检测并进入保温
          
          由此可见面向过程比较直接高效，而面向对象则更易于复用、扩展和维护，因为类是一直在的，需要做什么可以再另外定义拓展

- 面向过程的三大特性

  - 封装

    封装的意义就是明确地标识出允许外界使用的所有成员函数以及数据，内部细节对外部调用透明，而外部调用也无需修改和关心内部实现。

  - 继承

    继承基类的方法，并做出自己的改变或者拓展；子类共性的方法或者属性直接使用父类的即可，不用自己额外再定义，然后子类只需要专注于自身个性化的改变和拓展

  - 多态

    多态就是同一个接口，使用不同的实例而执行不同操作，便于接口的维护和拓展，可以将某一个子类切换成其他的子类，代码不需要做任何的改变，具有可替换性。

    有三个必要条件：继承、[方法重写](https://so.csdn.net/so/search?q=方法重写&spm=1001.2101.3001.7020)、父类引用指向子类对象

    [参考](https://blog.csdn.net/qfguan/article/details/121226260?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-121226260-blog-127827982.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-121226260-blog-127827982.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1)

### 21.synchronized的锁升级

[参考](https://blog.csdn.net/weixin_45794641/article/details/123255683)

### 22.垃圾回收器是如何判断是否是垃圾


## 七.Java Web & 网络

### 1.cookie和session的区别

### 2.请介绍一下什么是HTTP协议

### 3.cookie和session如何实现登陆,他们之前是怎么相互联系工作的

### 4.get和post的区别

- get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；post请求一般是去提交数据。

- get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，

  不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；

  post请求是没有的长度限制，请求数据是放在body中；

- get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。

- get请求可以被缓存，post请求不会被缓存。

- get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中。

### 5.TCP和UDP的区别

- TCP 面向连接（如打电话要先拨号建立连接）提供可靠的服务，UDP 是无连接的，即发送数据之前不需要建立连接，UDP 尽最大努力交付，即不保证可靠交付。
- UDP 具有较好的实时性，工作效率比 TCP 高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条 TCP 连接只能是一对一的，UDP 支持一对一，一对多，多对一和多对多的交互通信。
- UDP 分组首部开销小，TCP 首部开销 20 字节，UDP 的首部开销小，只有 8 个字节。
- TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流，UDP 是面向报文的一次交付一个完整的报文，报文不可分割，报文是 UDP 数据报处理的最小单位。
- UDP 适合一次性传输较小数据的网络应用，如 DNS，SNMP 等。

### 6.计算机网络七层模型和各自的作用

- OSI七层标准模型包括物理层、链路层、网络层、传输层、会话层、表示层和应用层。

  其中各个层次的主要功能：

1. 物理层：主要通过物理媒介传输比特流，将上层传来的数据转为比特进行传输，也接收对方发送的比特并整理后发送给上层。(IEEE 802 1A)
2. 链路层：主要负责将数据分成数据帧进行传输，并进行错误检测和纠正。(MAC)
3. 网络层：负责数据在网络中的传输，包括路由选择，分组转发和数据寻址以及拥塞控制等。(IP)
4. 传输层：主要负责数据传输的可靠性和流量控制，同时还包括分段、建立连接和断开连接等功能。(TCP，UDP)
5. 会话层，主要是负责及建立、管理和终止会话，提供会话控制和绘画同步等服务，还负责各个应用程序之间的数据交换。(SMTP)
6. 表示层：负责数据格式的压缩和解压、加密与解密和数据格式转换等服务。(SNMP)
7. 应用层：主要提供各种服务和应用程序，如电子邮件、文件传输、远程登录、Web浏览等等。(FTP)

[参考](https://blog.csdn.net/weixin_46048542/article/details/121621105)

### 7.Http协议是处于哪层网络模型，作用是？

- HTTP协议

  Hyper Text Transfer Protocol，全称为"超文本传输协议"，是客户端浏览器或者是其他的程序和Web服务器之间的应用层通讯协议，他通常工作在TCP之上，他指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。

- 作用

  1. HTTP协议用于客户端和服务端之间的通信
  2. HTTP协议是一种用来从WWW服务器传输超文本到本地浏览器的传送协议
  3. HTTP能够使得浏览器更加的高效，使得网络传输减少
  4. HTTP协议可以保证计算机正确快速的传输超文本协议，除此之外，还能够确定传输文档当中的那一部分，以及那部分内容首先显示等等。

  [参考](https://blog.csdn.net/2301_76334474/article/details/128818574)

### 8.HTTP和HTTPS的区别

- HTTP的连接很简单，明文传输，通过80端口连接

- HTTPS是由SSL+HTTP构建的可进行身份认证、加密传输的协议，相对更安全，通过443端口连接。

- 
  HTTPS需要到证书颁发机构申请证书（SSL的专业证书需要购买，功能越是强大的证书费用越高。）

### 9.请求头中keep-alive的作用

### 10.csrf跨域攻击

### 11.前后分离架构session的失效以及前后分离的登录实现

前后台分离项目session不能获取到的原因是因为跨域导致请求无法携带和服务器对应的cookie

[参考](https://blog.csdn.net/Dailyblue/article/details/125436846)

## 八.Mybatis和Mysql

## 八.一Mybatis & Mybatis-plus

### 1.什么是ORM

- 概念

  Obejct Relational Mapping的缩写,译为对象关系映射,解决了对象和关系型数据之间的数据交互问题;

  他的作用是在关系数据库和对象之间做一个映射,这样我们在具体的数据库操作的升级后,
  就不需要再去和复杂的sql语句打交道,只要想平时操作对象一样操作它就可以了

- 作用

  使用面向对象编程时，数据很多时候都存储在对象里面，具体来说是存储在对象的各个属性（也称成员变量）中。例如有一个 User 类，它的 id、username、password、email 属性都可以用来记录用户信息。当我们需要把对象中的数据存储到数据库时，按照传统思路，就得手动编写 SQL 语句，将对象的属性值提取到 SQL 语句中，然后再调用相关方法执行 SQL 语句。

  而有了 ORM 技术以后，只要提前配置好对象和数据库之间的映射关系，ORM 就可以自动生成 SQL 语句，并将对象中的数据自动存储到数据库中，整个过程不需要人工干预。在 Java 中，ORM 一般使用 XML 或者注解来配置对象和数据库之间的映射关系。

- ![img](img/dao.png)

- [概念参考](https://blog.csdn.net/weixin_45847691/article/details/125582970) [为什么要使用ORM](https://blog.csdn.net/u010947534/article/details/90669452)




### 2.Mybatis的Dao怎么运行



### 3.半自动和全自动ORM框架

- 持久化框架出现之前

  1. 加载驱动程序
  2. 获取数据库连接
  3. 创建statement/PerparedStatement对象
  4. 操作数据库
  5. 关闭连接

- Mybatis实现机制

  1. 读取Mybatis的全局配置文件mybatis-config.xml
  2. 创建SqlSessionFactory工厂
  3. 创建SqlSession会话
  4. 执行查询操作

- Hibenate实现机制

  1. 构建 `Configuration`实例，初始化该实例中的变量
  2. 加载 `hibenate.cfg.xml` 文件到内存
  3. 通过 `hibenate.cfg.xml` 文件中的 mapping 节点配置并加载 xxx.hbm.xml 文件至内存
  4. 利用 `Configuration`实例构建 `SessionFactory` 实例
  5. 由`SessionFactory` 实例构建 `session`实例
  6. 由 `session`实例创建事务操作接口 `Transaction` 实例
  7. 执行查询操作

- 总结

  1. 传统的 `jdbc` 是手工的，需要程序员加载驱动、建立连接、创建 `Statement` 对象、定义SQL语句、处理返回结果、关闭连接等操作。

  2. Hibenate

     `Hibernate` 是自动化的，内部封装了`JDBC`，连 SQL 语句都封装了，理念是即使开发人员不懂SQL语言也可以进行开发工作，向应用程序提供调用接口，直接调用即可。

  3. `Mybatis` 是半自动化的，是介于 `jdbc` 和 `Hibernate`之间的持久层框架，也是对 `JDBC` 进行了封装，不过将SQL的定义工作独立了出来交给用户实现，负责完成剩下的SQL解析，处理等工作。

### 4.Mybatis和Hibernate二者的区别

- 相同
  1. 持久层框架,帮助开发人员简化工作
  2. 都是对JDBC进行封装
- 不同点

### 5.Mybatis和Mybatis-Plus的关系

Mybatis-Plus插件的了解

Mybatis-Plus四大接口

Mybatis拦截器

### 6.MyBatis插件的实现原理(mybatis分页插件的实现)

### 7.主键回填

![](img/主键回填.png)

### 8.Mapper是如何创建的

利用AOP机制，使用MapperProxyFactory通过反射创建

### 9.mybatis如何实现自定义插件

### 10.mybatis-plus实现分页

### 11.mybatis如何执行mapper里面的sql语句

### 12.mybatis的dao如何生成

## 八.二Mysql

### 1.InnoDB和MyISAM内存引擎的区别

MyISAM(发音为my son)

1. 总

   - InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引
   - MyISAM 不支持事务、也不支持外键，优势是访问的速度快。对事务的完整性没有要求、以 SELECT 和 INSERT 为主的应用可以使用这个存储引擎

2. 分

   | 对比项                                 | InnoDB                                        | MyISAM                                                   |
   | -------------------------------------- | --------------------------------------------- | -------------------------------------------------------- |
   | 事务                                   | 支持                                          | 不支持                                                   |
   | 锁类型                                 | 行级锁,表级锁                                 | 表级锁                                                   |
   | 缓存                                   | 缓存索引和数据                                | 只缓存索引                                               |
   | 主键                                   | 必须有,用于实现聚簇索引                       | 可以没有                                                 |
   | 索引                                   | B+树,主键是聚簇索引(数据文件和索引绑定在一起) | B+树,非聚簇索引                                          |
   | select count(*) from table(查询表行数) | 较慢,InnoDB需要扫描全表                       | 贼快,MyISAM用一个变量保存饿了表的行数,只需读取该变量即可 |
   | hash索引                               | 支持                                          | 不支持                                                   |
   | 记录存储顺序                           | 按主键大小有序插入                            | 按记录插入顺序保存''                                     |
   | 外键                                   | 支持                                          | 不支持                                                   |
   | 全文索引                               | 5.7之后支持                                   | 支持                                                     |
   | MVCC(多版本并发控制)                   | 支持                                          | 不支持                                                   |


### 2.order by优化

### 3.limit的优化

### 4.分页查询id不连续

### 5.事务隔离级别

### 6.mysql的备份机制

### 7.mysql锁有哪些

### 8.MVCC

### 9.Mysql两段提交

### 10.binlog和redolog

### 11.为什么说InnoDB必须要有主键并且推荐使用自增整型主键呢

1.InnoDB存储引擎的数据结构必须需要一个主键才可以组织起来，如果用户使用InnoDB存储引擎建立表的时候，没有指定主键，则Mysql会自动的帮你找到一个合适的唯一索引作为主键，若找不到符合条件唯一索引条件的字段时，会生成类似于ROW_ID的虚拟列充当该InnoDB表的主键；

2.整型的存储比字段类型要小，而且因为是InnoDB存储引擎使用的是B+Tree数据结构，在进行查询数据是需要对每个元素进行比较，而整型的对比效率是高于其他数据结构的，字符串等。

注:mysql的InnoDB数据结构为页

[参考](https://blog.csdn.net/a1_HelloWord/article/details/104341349?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-104341349-blog-120095228.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-104341349-blog-120095228.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1)

[mysql数据结构参考](https://blog.csdn.net/small_engineer/article/details/123792216)

### 12.索引失效

1. 如果查询条件中有or，即使其中有部分条件是索引字段,也不会使用索引
2. 复合索引,查询条件不使用索引齐纳面的字段,后续字段也将无法使用索引
3. 以%开头的like索引

### 13.平常时如何进行sql优化

三个维度:表结构,索引,sql语句进行优化

- 定位查询慢的语句

  开启慢日志(仅仅是在测试环境下,生产环境中谨慎使用)

- 使用explain对执行的语句进行分析(从哪些维度进行分析)

  - 分析索引的使用情况(explain解析之后显示的type栏)
    - system：一般只有一行数据,非常快,基本用不到
    - const：通过一次索引就能找到数据,一般使用的是主键索引
    - ref：使用的是普通索引,eq_ref使用的是唯一索引
    - range：查询索引的结果是一个范围,性能要稍微低一些,主要是用在<，>，between等操作上
    - index ：Full Index Scan，Index与All区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘读取的）
    - ALL：没有使用索引,全表扫描
  - extra:额外的信息
    - Using index：
      1. Extra为Using index说明，SQL所需要返回的所有列数据均在一棵索引树上，而无需访问实际的行记录。
      2. 这类SQL语句往往性能较好。说明他没有查询到数据表，只用索引表就完成了整个查询，也叫做覆盖索引
    - Using where:
      1. 表明使用了where在server层进行过滤，如果只出现where，则需要回表查询；
      2. 使用了where条件的SQL，并不代表不需要优化，往往需要配合explain结果中的type（连接类型）来综合判断；
  - rows：表示扫描的行数
  - filters：得到的结果和扫描行数的比率,100%为最好

### 14.事务的实现

二段提交,事务提交,回滚

### 15.如何检查死锁

- 查看死锁

  ```mysql
      1、查看正在进行中的事务
  SELECT * FROM information_schema.INNODB_TRX
      2、查看正在锁的事务
  SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
      3、查看等待锁的事务
  SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
      4、查询是否锁表
  SHOW OPEN TABLES where In_use > 0;
  在发生死锁时，这几种方式都可以查询到和当前死锁相关的信息。
      5、查看最近死锁的日志
  show engine innodb status
  ```

- 解决死锁

  ```mysql
  -- 查看当前正在进行中的进程
  show processlist
  -- 或者
   SELECT * FROM information_schema.INNODB_TRX;
  -- 杀掉进程对应的进程id
  kill id
  -- 验证(kill后在看是否还有锁)
  SHOW OPEN TABLES where In_use > 0;
  ```

  [参考](https://blog.csdn.net/wufagang/article/details/125554792)

### 16.三大范式

- **第一范式** ：任何表都有一个主键，并且每一个字段的原子性不可再分。
- **第二范式**：第二范式在第一范式的基础上，所有的非主键字段，完全依赖主键，不能产生部分依赖。容易产生冗余数据
- **第三范式**： 在第二大范式的基础上，所有非主键字段直接依赖主键，不能产生传递依赖。
- [参考](https://blog.csdn.net/weixin_41765786/article/details/124164961)

### 17.MySql的事务是什么?什么是ACID

- 数据库事务是指数据库管理系统中的一个操作序列，这些操作必须作为一个不可分割的单元执行，即要么全部执行成功，要么全部失败回滚。事务通常涉及到对数据库中的数据进行读写操作。

- 四种原则

  1，事务的特征原子性(Atomicity)

  指事务中的操作，要么都完成，要么都取消。

  2，一致性(Consistency)

  指事务中的操作保证数据库中的数据不会出现逻辑上不一致的情况。

  3，隔离性(Isolation)

  指当前的事务与其他未完成的事务是隔离的。

  4，永久性(Durability)

  指对事务发出COMMIT命令后，事务的效果是永久的。

### 18.mysql explain的执行过程

### 19.binlog的作用

[参考](https://blog.csdn.net/weixin_36128239/article/details/113589805)

### 20.mysql触发器



## 九.并发

### 1.高并 发处理方法

[参考](https://blog.csdn.net/qq_42362022/article/details/124453576)

## 十.运维

### 1.linux是如何查看系统日志的

找到指定日志文件,使用tail或者cat指令进行查看

## 十一.前端

### 1.vue的生命周期

### 2.axio参数提交方式

- param
- data

### 3.param和query传递参数的区别

### 4.vue的两大特点

- 响应式编程：MVVM思想实现数据的双向绑定，让开发者不用再操作dom对象。
- 组件化：将单页应用中的各种模块拆分到一个一个单独的组件中,进行单独开发。

### 5.promise和aysnc的区别

## 十二.微服务

### 1.分布式事务的解决方案

### 2.springcloud常用组件

- 服务与注册
- 负载均衡
- 网关
- 链路追踪
- 分布式事务
- 服务熔断(Sentinel)

### 3.分布式id生成

## 十三.拓展

### 1.技能点

1. java基础，面向对象
2. 数据结构和算法（冒泡，字符串KMP）
3. 设计模式（单例，工厂，代理，策略等等）
4. 多线程并发，juc包
5. JVM虚拟机（类加载机制，内存分布，垃圾回收）
6. web基础知识（servlet，jsp，html+js+css，ajax，jquery）
7. spring框架（IOC,MVC,AOP,事务）
8. Mybatis（基本使用，缓存，AOP使用，插件实现）
9. 前后分离架构（webservice，jwt，security权限框架）
10. vue知识（es6，vue组件通信，生命周期，v标签）
11. nginx（反向代理，文件服务器fastdfs，https，负载均衡）
12. 微服务（注册中心，配置中心，消息通信，网关，断路器，限流，分布式事务，链路追踪）
13. redis（基础数据类型，一致性问题、穿透、多级缓存、分布式锁、分布式架构，持久化，淘汰策略）
14. mq（丢包，顺序，幂等，延时，死信，分布式事务，最终一致性）
15. xxl-job（分布式任务调度，补偿机制）
16. 项目业务
17. mysql（基础类型，日期查询，索引，sql优化，日志，备份，事务，锁）

### 2.SKU&SPU(电商最基本概念)

### 3.常见的加密算法

- MD5
- DES
- RSA

### 4.企业级MQTT物联网接入平台

### 5.shell脚本

[shell脚本编写冒泡](https://blog.csdn.net/weixin_58544496/article/details/126695151)

## 鱼皮

### Day01                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

#### 1.什么是数据库事务，讲一下数据库ACID的特性

- 数据库事务：数据库管理系统中的一个操作序列，这些操作必须作为一个不可分割的单元执行，即要么全部执行成功，要么全部失败回滚
- ACID
  1. 原子性：事务是一个原子操作，要么全部提交，要么全部回滚。
  2. 持久性：一旦事务提交，其所做的改变必须永久的保存到数据库中。
  3. 隔离性：数据库系统必须保证事务之间相互隔离，不互相干扰。
  4. 一致性：事务执行结束之后，数据必须保持一会执行状态。

#### 2.什么是字节码，字节码的好处有哪些

- 字节码：能够被java虚拟机编译的编码就是字节码，一般是以.class结尾的文件。
- 字节码的好处：一次编译，多处运行。
  1. 可移植性：由于字节码是中间代码，所以可以在任何支持 JVM 的平台上运行，使得 Java 程序具有很好的可移植性。这也是 Java 跨平台的重要特性之一。
  2. 安全性：由于字节码需要在 JVM 中运行，所以可以对字节码进行安全检查，以确保程序不会对系统造成威胁。
  3. 性能：由于字节码是一种紧凑的二进制格式，相比于直接编译为机器码，可以更快地加载和传输，同时也可以在运行时进行动态优化，提高程序的执行效率。
  4. 可读性：相比于直接编译为机器码，字节码具有更好的可读性，可以方便地进行反汇编和调试。

#### 3.JDK，JVM，JRE的区别

1. JDK：Java开发工具包，包含了编写，编译，调试和运行Java程序所需的所有工具和组件

   JDK=JRE+java开发工具+Java开发基础类库

2. JRE：JRE是Java的运行时环境，包括了Java虚拟机(JVM)和Java标准类库

3. JVM：JVM是Java虚拟机，是Java程序运行的环境，负责将Java代码转换为可以在计算机上运行的机器码，并提供必要的环境支持

### Day02

#### 1.Java，C++，Go语言的区别以及各自的优缺点

- JAVA

  - 优点

  - 简单易学，代码可读性强
    - 跨平台，一次编写可以在多个操作系统上运行
    - 面向对象，支持继承、多态等特性
    - 丰富的类库，可以快速开发应用程序
    - 自动内存管理，减少了内存泄漏的可能性

  - 缺点:
    - 由于JVM的存在，运行速度相对较慢
    - 对于实时性要求较高的场景，Java的表现可能不如C++和Go

- C++

  - 优点：
    - 速度快，适合编写需要高性能的应用程序
    - 应用广泛，特别是在游戏开发、操作系统和嵌入式系统开发方面
    - 灵活性高，可以直接访问硬件和内存

  - 缺点：
    - 学习难度较高，需要掌握指针、内存管理等底层知识
    - 容易出现内存泄漏和指针错误等问题
    - 编写代码过程中需要更多的手动管理，相比Java更容易出错

- Go:

  - 优点：
    - 高并发，天生支持协程，能够轻松编写高效的并发程序
    - 简单易学，语法简洁，上手容易
    - 静态类型语言，可以避免一些潜在的运行时错误
    - 快速编译，可以快速构建和部署应用程序

  - 缺点：
    - 缺乏丰富的类库，与Java和C++相比有些不足
    - 在一些性能要求极高的场景中可能不如C++表现
    - 语言本身还比较年轻，相关生态和工具还需要进一步完善


使用场景：

- **JAVA**
  - 适合开发企业级应用程序、后端服务等。
- C++
  - 适合开发需要高性能和高可靠性的应用程序，特别是在游戏开发、操作系统和嵌入式系统开发方面。
- GO
  - 适合开发高并发的后端服务、微服务、容器化应用程序等.

#### 2.什么是redis，redis有哪些特点？redis有哪些常见的应用场景

- redis：开源的很高性能键值存储系统，支持多种类型的数据结构，八大基本数据类型：string，set，zset，hash，list；Geo，Bitmap，Hyderlonger(统计数据)，并提供了丰富的操作这些数据结构的命令
- 特点：
  1. 高性能：redis使用内存来保存数据，并且在数据结构存储在单一的进程中，因此速度非常快
  2. 多样的数据结构类型：redis支持多种数据结构，可以支持不通的应用场景，比如zset可以用来排名，Geo可以用来查找附近店铺
  3. 持久化：redis支持多种持久化策略
  4. 分布式：redis支持分布式部署，可以将数据分布在多个节点上
- 应用场景：
  1. 缓存：Redis可以作为缓存使用，加速数据读取和响应速度。
  2. 消息队列：Redis提供了列表和发布/订阅功能，可以用来实现消息队列。
  3. 计数器：Redis的计数器功能非常高效，可以用来实现页面访问量、点击量等的计数。
  4. 排行榜：Redis的有序集合功能可以用来实现排行榜。
  5. 分布式锁：Redis可以用来实现分布式锁，保证多个进程之间的互斥访问。
  6. 实时数据分析：Redis可以作为实时数据分析的缓存层，加速数据分析速度。

#### 3.计算机七层模型和各自的作用

1. 物理层：主要负责通过物理媒介传输比特流，如电缆、光纤、无线电波等。物理层规定了物理连接的规范，包括电缆的类型、接口的规范等。
2. 数据链路层：主要负责把数据分成数据帧进行传输，并对错误进行检测和纠正。数据链路层还负责物理地址的分配、数据流量控制、错误校验等。
3. 网络层：主要负责数据在网络中的传输，包括路由选择、分组转发、数据报文的封装等。网络层还处理数据包的寻址和控制流量等。
4. 传输层：主要负责数据传输的可靠性和流量控制等，同时还包括分段、组装、连接建立和断开等功能。传输层的最重要的两个协议是TCP和UDP。
5. 会话层：主要负责建立、管理和终止会话，提供会话控制和同步等服务。会话层还负责处理多个应用程序之间的数据交换。
6. 表示层：主要负责数据格式转换、加密解密、压缩解压等服务。表示层使得应用程序可以使用不同的数据格式和编码，同时还提供了数据的安全性和完整性保护等服务。
7. 应用层：主要提供各种服务和应用程序，如电子邮件、文件传输、远程登录、Web浏览等。应用层服务可以使用不同的协议实现，如HTTP、SMTP、FTP、TELNET等。

### Day03

#### 1.JDK动态代理和CGLIB动态代理的区别是什么?

1. JDK和CGLIB动态代理的区别

   JDK代理使用的是反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
   CGLIB代理使用字节码处理框架asm，对代理对象类的class文件加载进来，通过修改字节码生成子类。
   JDK创建代理对象效率较高，执行效率较低；
   CGLIB创建代理对象效率较低，执行效率高。
   JDK动态代理机制是委托机制，只能对实现接口的类生成代理，通过反射动态实现接口类；
   CGLIB则使用的继承机制，针对类实现代理，被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的，因为是继承机制，不能代理final修饰的类。
   JDK代理是不需要依赖第三方的库，只要JDK环境就可以进行代理，需要满足以下要求：
    1.实现InvocationHandler接口，重写invoke()
    2.使用Proxy.newProxyInstance()产生代理对象
    3.被代理的对象必须要实现接口
   CGLib 必须依赖于CGLib的类库,需要满足以下要求：
    1.实现MethodInterceptor接口，重写intercept()
    2.使用Enhancer对象.create()产生代理对象

2. 使用JDK还是CGLIB
      1)如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP，可以强制使用CGLIB实现AOP
      2)如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换

3. 强制使用CGLIB实现AOP的方法
      1）添加CGLIB库(aspectjrt-xxx.jar、aspectjweaver-xxx.jar、cglib-nodep-xxx.jar)
      2）在Spring配置文件中加入<aop:aspectj-autoproxy proxy-target-class=“true”/>

#### 2.MySQL日志，以及binlog，redolog，undolog分别有什么作用

Mysql日志主要包括
1、慢查询日志：记录执行时间超过long_query_time的所有查询，方便我们对查询优化

2、通用查询：日志:记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令,对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。

3、查询日志：错误日志:记录MySQL服务的启动、运行或停止MySQL服务时出现的问题,方便我们了解服务器的状态，从而对服务器进行维护。

4、二进制日志（bin log）:记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以吸服务器遇到故障时数据的无损失恢复。

5、中继日志:用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。

6、数据定义语句日志:记录数据定义语句执行的元数据操作。

- binlog（归档日志）：server 层的日志，用于实现数据备份和主从复制
- redo log（重做日志）：InnoDB 引擎层的日志，保证了事务的持久性，用于实现数据库宕机后的故障恢复
- undo log（回滚日志）：InnoDB 引擎层的日志，保证了事务的原子性，用于实现事务回滚和MVCC

redo log 和 undo log 的区别：

- redo log 是记录事务完成后的状态，记录的是更新后的值
- undo log 是记录事务开始前的状态，记录的是更新前的值

#### 3.Spring框架是什么？使用Spring框架有什么好处？

- Spring 框架是一个开源的 Java 企业应用程序框架，它通过依赖注入(Dependency Injection)和面向切面编程(Aspect Oriented Programming)等技术为开发者提供了一个全面的编程和配置模型。它可以降低 Java 开发的复杂度，提高代码的可维护性和可测试性，使得开发者能够更专注于业务逻辑的实现。

  

  使用Spring框架有以下好处：

  1. 依赖注入(Dependency Injection)：通过 Spring 框架的依赖注入功能，开发者可以将应用程序中的不同组件之间的依赖关系交给 Spring 来管理，从而降低组件之间的耦合度，并方便后续的组件替换和维护。
  2. 面向切面编程(Aspect Oriented Programming)：Spring 框架提供了面向切面编程的支持，可以将应用程序的不同功能抽象成切面，并将这些切面与应用程序中的不同组件关联起来，从而降低了应用程序中的重复代码量，并提高了代码的可重用性和可维护性。
  3. 提供了多种技术整合方案：Spring 框架可以与其他的 Java 企业应用程序框架和技术进行整合，如 Hibernate、MyBatis、Struts、JSF 等，从而降低了技术整合的复杂度。
  4. 支持声明式事务管理：Spring 框架提供了声明式事务管理的支持，开发者可以通过配置来管理应用程序中的事务，从而简化了事务管理的过程。
  5. 提供了 IoC 容器：Spring 框架提供了一个 IoC 容器，可以对应用程序中的不同组件进行管理，并支持对组件进行 AOP 增强，从而实现了应用程序中的组件解耦和高度可配置性。
  6. 便于测试：Spring 框架可以方便地进行单元测试和集成测试，提高了代码的可测试性和可靠性。

### Day04

#### 1.Http协议是处于哪层网络模型，作用是？

- HTTP协议
- 作用
- http和https的区别

#### 2.Java final关键字和static关键字的区别

- 修饰成员变量
- 修饰方法
- 修饰类

#### 3.什么进程和线程？他们有哪些区别和联系

- 在操作系统中，进程是指一个正在执行中的程序，而线程是进程的一部分，是一个程序中执行的代码片段。

  **进程是操作系统资源分配的最小单位**，一个进程至少包括一个线程，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自己的地址空间。进程通信需要通过进程间通信机制（IPC）来实现。

  **线程是程序执行的最小单位**，一个进程中可以包含多个线程，它们共享进程的内存空间和系统资源。多个线程可以并发执行，从而提高了程序的运行效率，同时也会带来线程安全等问题。线程之间的通信可以通过共享内存、信号量等机制实现。

  进程和线程的区别和联系如下：

  - 资源分配：进程拥有自己的内存空间等系统资源，而线程共享进程的资源；
  - 独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源；
  - 调度：进程间调度的开销比线程大，线程的调度开销小，可以并发执行；
  - 并发性：多个进程之间相互独立，多个线程可以并发执行；
  - 同步：进程间通信需要通过IPC机制，线程间同步可以通过共享内存、信号量等机制实现。

  在实际开发中，多线程应用更加常见，因为线程的开销小，执行效率高，适用于需要并发执行的场景。但需要注意线程安全问题。而多进程应用通常更加稳定，但开销较大，适用于需要独立运行的场景。

- [参考1](https://blog.csdn.net/mu_wind/article/details/124616643)

  [参考2](https://blog.csdn.net/lurong66/article/details/107920379)

### Day05

#### 1.Spring的两大核心是什么？请简单讲一下你对他们的理解

- IOC
  - IOC(Inverse Of Controll,控制反转)：就是原来代码里面需要自己手动创建的对象，依赖，反转给Spring来帮忙实现。我们需要创建一个容器，同时需要一种描述来让容器知道要创建的对象与对象之间的关系。
  - 在Spring中BeanFactory就是IOC容器，在Spring初始化的时候，创建容器，并将需要创建对象和对象的关系（xml，注解）通过BeanDefinitionReader加载到BeanDefinition中并保存在BeanDefinitionMap中，然后再由IOC容器创建bean对象.




- 两种bean的注册方式
  -  方法1：通过@Bean+@Configuration的方式直接定义要创建的对象与对象的关系
  - 方式2：通过@Component定义类，这种方式必须使用@ComponetScan定位Bean扫描路径

- AOP
  - AOP
    在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口采用 JDK 动态代理，如果是类采用CGLIB 方式实现动态代理。


#### 2.Java中的hascode和equals方法是什么?他们和==有什么区别？

- hascode

  他返回的就是根据对象的内存地址换算出的一个值

- equals

  用来比较连个对象的内容是否相等，由于所有的类都是继承自java.lang.object类的，所以适用于所有对象，如果没有对该方法进行覆盖，调用的仍然是Obejct类的方法，而Object中的equals方法返回的却是==的判断

- ==

  ==比较的是变量(栈)中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同的一个对象。比较的是真正意义上的指针操作

  1. 比较的是操作符两端的操作数是否是同一个对象
  2. 两边的操作数必须是同一类型(可以使父子之间)才能编译通过
  3. 比较的是地址

#### 3.死锁是什么？如何简单预防死锁

- 死锁是指两个或多个进程互相等待对象释放资源而无限等待的状态，导致程序无法执行下去，称为死锁。
- 预防和避免死锁、
  1. 避免使用多个锁：在设计程序时，应尽量减少使用多个锁，或者在使用多个锁时，尽量将锁的持有时间缩短到最小。这可以减少死锁的概率。
  2. 避免嵌套锁：在使用嵌套锁时，需要注意锁的顺序，以避免不同线程获取锁的顺序不同而导致死锁。如果必须使用嵌套锁，可以使用统一的锁顺序来避免死锁。
  3. 使用超时机制：在获取锁时，可以设置一个超时时间，如果在指定时间内没有获取到锁，就放弃锁的获取，避免一直等待锁而导致死锁。
  4. 使用死锁检测和恢复机制：可以使用死锁检测机制来检测死锁的发生，并采取恰当的措施来解决死锁问题，比如终止一个进程或者回滚一个事务。
  5. 避免循环等待：在获取锁的时候，应该避免循环等待，即每个线程只能持有一个锁，而获取其他锁时必须先释放原有锁。

### Day06 

#### 1.什么是反射机制？说说反射机制的优缺点、应用场景？

- 反射

  指在运⾏状态中，对于任意⼀个类都能够知道这个类所有的属性和⽅法；并且对于任意⼀个对

  象，都能够调⽤它的任意⼀个⽅法；这种动态获取信息以及动态调⽤对象⽅法的功能称为反射机制。

- 反射涉及到四个核⼼类

  • java.lang.Class.java：类对象；

  • java.lang.reflect.Constructor.java：类的构造器对象；

  • java.lang.reflect.Method.java：类的⽅法对象；

  • java.lang.reflect.Field.java：类的属性对象；

- 反射有什么⽤？(优点)

  • 操作因访问权限限制的属性和⽅法；

  • 实现⾃定义注解；

  • 动态加载第三⽅jar包；

  • 按需加载类，节省编译和初始化APK的时间；

- 反射机制的缺点

  - 由于反射是动态的，所以它的运行效率较低，不如直接调用方法或属性。
  - 由于反射是动态的，所以它会破坏 Java 的封装性，可能会使代码变得复杂和不稳定。

- 反射⼯作原理

  当我们编写完⼀个Java项⽬之后，每个java⽂件都会被编译成⼀个.class⽂件，这些Class对象承载了这个类的所有信息，包括⽗类、接⼝、构造函数、⽅法、属性等，这些class⽂件在程序运⾏时会被ClassLoader加载到虚拟机中。当⼀个类被加载以后，Java虚拟机就会在内存中⾃动产⽣⼀个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是不透明的⽽已。

- 应用场景

  1. 动态代理，因为不确定需要代理的类，所以需要通过反射动态的获取
  2. RPC框架，RPC框架就是动态的生成类对象，然后调用方法的。

#### 2.数据库索引是什么，有什么作用，什么场景适合使用索引？

数据库索引是一种数据结构，就想书的目录一样，它可以帮助我们快速定位到想要的数据。

**优点**

- 可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

**缺点**

- 需要占用物理空间，数量越大，占用空间越大；
- 索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。

索引不是万能钥匙，它也是根据场景来使用的

**什么场景适合使用索引？**

- 频繁使用的列，主键、外键
- 字段有唯一性限制的，比如商品编码，可以使用唯一索引
- 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的

还有一点要注意的是索引失效的场景，本来使用索引是为了加快检索速度的，一旦索引失效，不仅起不了作用还占用空间。

**索引失效**

- 使用函数、计算、类型转换

使用这些以后，索引中存的不是函数计算后的值，自然用不到索引

- like %xxx %xxx%

不符合最左匹配原则

- or 只有一边用上了索引，也会导致索引失效
- 联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like '林%'这种）的时候，就会停止匹配

**什么时候不适合创建索引？**

- **WHERE 条件，GROUP BY，ORDER BY 里用不到的字段**，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- **字段中存在大量重复数据**，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- **表数据太少**的时候，不需要创建索引；
- **经常更新**的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

#### 3.HTTP状态码

#### 一信 二成 三重 四五败

- 1xx 一信
    提示信息,是协议处理的中间状态,还需要后续操作 ( 感觉一般也不会遇到 )

- 2xx 二成

  - 200 : 常见的成功状态码
  - 204 : 200状态码 - ***无Body版***
  - 206 : 200状态码 - ***part版*** ( 表示响应返回的body数据不是资源的全部 )

- 3xx 三重

  - 301 : 永久重定向
  - 302 : 301状态码 - ***临时版*** ( 临时重定向 )
  - 304 : 不具有跳转意义,表示资源未修改,重定向到缓存 ( 304 Not Modified )

- 4xx 四败

  客户端!!!

  - 404 : 资源不存在或者未找到 ( 404 NOT FOUND )
  - 400 : 请求报文有错误 ( 记忆方法: 400最小 发生在 Http 第一步(发送请求)中 )
  - 401 : 请求需要认证
  - 403 : 禁止访问 ( 403 Forbidden )

- 5xx 五败

  服务端!!

  - 500 : 笼统错误码
  - 502 : 服务器网关或者代理出现问题 ( 502 Bad GateWay )
  - 503 : 服务器正忙,无法处理请求 ( 503 Unavailable )

### Day07

#### 1.Java 访问修饰符 public、private、protected，以及无修饰符（默认）的区别

- `public` > `protected` > `default` > `private`。
- public 当前类，同包，子类，不同包都可以访问
- protected 当前类，同包，子类都可以访问
- default 当前类，同包都可以访问
- private 当前类可访问

#### 2.线程间有哪些通信方式？

线程间通信方式

- **互斥锁**提供了以排他方式防止数据结构被并发修改的方法。
- **信号量** 和互斥锁的区别在于：互斥锁只允许一个线程进入临界区，信号量允许多个线程同时进入临界区 互斥锁使用对同一个资源的互斥的方式达到线程同步的目的，信号量可以同步多个资源以达到线程同步。PV操作
- **读写锁**允许多个线程同时读共享数据，而对写操作是互斥的。
- **条件变量**可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- **自旋锁**与互斥量类似，也是只有解锁和加锁两种状态，它与互斥量的区别在于，它不会阻塞线程。
- **信号机制**(Signal) 类似进程间的信号处理，主要用于处理异常状况，用特定的码代指信息。

进程间的通信方式

- ### 管道

  管道是一种单向的数据传输方式，实现线程间的通信需要两个管道。管道这种通信方式的缺点就是通信效率低，好处就是实现简单。

- ### 消息队列

  为了解决管道通信效率低，可以使用消息队列。消息队列这种通信方式就是有一个生产者，一个消费者，运送数据的效率取决于消息队列的容量。消息队列的缺点就是，不适合传输较大的数据。 另外传输数据要进行内核态与用户态之间的拷贝，效率比较低。

- ### 共享内存

  为了解决内核态与用户态之间数据拷贝带来的开销，可以使用共享内存，共享内存就是通过指针的指向改变来完成数据的访问。优点就在于可以省去拷贝开销，但是随之而来的问题就是对共享资源互斥访问需要控制，不然会带来安全性问题。

- ### 信号量

  为了解决对共享资源访问的同步、互斥问题，可以使用信号量。信号量其实就是一个整型计数器，用来记录资源的数量，通过PV操作来实现进程间的同步、互斥流程。

- ### 信号

- 对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。

  信号跟信号量虽然名字相似度很高，但两者用途完全不一样。信号是通过固定的信号标志来传达信息。

- ### Socket

  前面涉及到的都是同一台主机间通信方式，还有不同主机间的通信，那就要用到Socket.

线程间通信与进程间通信的区别

- **线程是轻量级的进程** 系统进行资源调度的基本单位是进程，但是因为进程上下文切换开销太大，所以有了线程，节省开销。 线程本身也是共享进程的内存，上下文切换方便。
- **安全性** 线程间通信的安全性相对较低，需要采用同步机制来保证共享变量的正确性； 而进程间通信的安全性相对较高，进程之间相互隔离，不会对对方的内存进行非法操作。

#### 3.什么是分布式，为什么需要分布式

- 分布式是指将一个大型系统分割成多个子系统，每个子系统都可以独立运行，但又可以通过网络协同工作，共同完成系统的功能。

- 分布式的出现主要是为了解决单机系统存在的各种问题，包括：

  性能瓶颈：单机系统在面对高并发请求时，由于硬件资源有限，容易出现性能瓶颈。

  可靠性问题：单机系统可能因为硬件故障、系统崩溃等原因导致整个系统不可用。

   扩展性问题：单机系统的扩展性有限，一旦需要增加处理能力，就必须增加更多的硬件资源，成本高昂。

- **微服务是一种分布式系统的实现方式**。微服务将应用程序拆分成多个小型服务，每个服务都可以运行在不同的计算机或处理器上，因此可以通过网络连接来协同工作。微服务还可以使用分布式技术（例如分布式数据库和消息队列等）来实现数据共享和通信。因此，**微服务通常是基于分布式系统的实现方式之一**。

### Day08

#### 1.你是怎么做 MySQL 数据备份的？比如怎么恢复半个月前的数据？

- MySQL 数据备份有多种方法，包括逻辑备份、物理备份、全备份和增量备份。你可以根据你的需求和环境选择合适的方式。如果你想要恢复半个月前的数据，你需要先确保你有半个月前的备份文件，然后使用相应的工具或命令进行还原。例如，如果你使用 **mysqldump** 命令进行了逻辑备份，那么你可以使用 source 指令或者 mysql 命令来导入备份文件。

- 常用的备份策略

  - 逻辑备份

    逻辑备份是使用 SQL 语句来导出和导入数据库的数据的方法。它的优点是简单易用，可以跨平台和存储引擎，可以部分备份和恢复。它的缺点是速度慢，占用空间大，可能影响数据库性能。

  - 物理备份

    物理备份是直接拷贝数据库的数据文件、配置文件和日志文件。它的优点是速度快，占用空间小，不影响数据库性能。它的缺点是恢复复杂，需要关闭数据库服务，可能导致数据不一致。

  - 全备份和增量备份

    全备份是指备份数据库中的所有数据，不管数据是否有变化。它的优点是恢复简单，不需要其他文件。它的缺点是占用空间大，耗时长，影响数据库性能。

    增量备份是指只备份上次全备份或增量备份后发生变化的数据，需要开启 binlog 日志功能. 它的优点是占用空间小，耗时短，不影响数据库性能. 它的缺点是恢复复杂，需要依赖 binlog 日志文件和全备份文件.

- 恢复数据

  找到指定的时间节点的备份文件，使用mysql命令备份到指定的数据库中

#### 2.什么是设计模式，为什么要学习和使用设计模式

设计模式是一套被反复使用、经过验证的、通用的解决特定问题的设计思想，是一种被设计师反复使用，经过时间验证的、解决特定问题的一种技术方案。
学习和使用设计模式可以帮助我们更好地理解软件设计中的问题，并提供一些可重用的解决方案：

1. 提高代码的可维护性：设计模式提供了一些通用的设计思想和模板，可以使代码更易于理解和维护，减少代码的复杂性。
2. 提高代码的可重用性：设计模式提供了一些可重用的解决方案，可以帮助我们避免重复造轮子，提高代码的重用性。
3. 提高代码的可扩展性：设计模式提供了一些通用的设计思想和模板，可以使代码更易于扩展，从而提高代码的可扩展性。
4. 提高代码的可靠性：设计模式提供了一些可重用的解决方案，可以帮助我们减少代码中的错误和漏洞，从而提高代码的可靠性。
5. **更好地组织代码**：设计模式提供了一些通用的设计思想和模板，可以帮助我们更好地组织代码，使代码更易于理解和维护。

以下是一些**常见的现实业务场景**和对应的设计模式：

1. 工厂模式：当需要创建多种具有相同特征的对象时，使用工厂模式可以将对象的创建与业务逻辑分离，降低代码的耦合度。 例如，在电商平台上，不同种类的商品都需要进行库存管理和订单管理，可以使用工厂模式来创建对应的库存管理器和订单管理器。
2. 单例模式：当需要确保系统中某个类只有一个实例时，可以使用单例模式，保证全局唯一性，避免资源的浪费。 例如，在 Web 应用中，有时需要保证所有请求都使用同一个数据库连接，可以使用单例模式来实现数据库连接池。
3. 观察者模式：当一个对象的状态发生改变需要通知其他对象时，可以使用观察者模式，将对象的状态与业务逻辑分离，提高系统的灵活性和可扩展性。 例如，在多人在线游戏中，玩家的行为会影响其他玩家的状态，可以使用观察者模式来实现游戏中的事件处理和状态同步。
4. 策略模式：当需要在运行时根据不同的情况采用不同的算法时，可以使用策略模式，将算法与业务逻辑分离，提高代码的可维护性和扩展性。 例如，在电商平台上，可以使用策略模式来实现不同的促销策略，例如满减、打折等。

### Day09

#### 1.什么是IOC容器，以及IOC的创建过程

- 基本概念
  - IOC(Inverse Of Controll,控制反转)：就是原来代码里面需要自己手动创建的对象，依赖，反转给Spring来帮忙实现。我们需要创建一个容器，同时需要一种描述来让容器知道要创建的对象与对象之间的关系。
  - 在Spring中BeanFactory就是IOC容器，在Spring初始化的时候，创建容器，并将需要创建对象和对象的关系（xml，注解）通过BeanDefinitionReader加载到BeanDefinition中并保存在BeanDefinitionMap中，然后再由IOC容器创建bean对象.
- 两种bean的注册方式
  - 方法1：通过@Bean+@Configuration的方式直接定义要创建的对象与对象的关系
  - 方式2：通过@Component定义类，这种方式必须使用@ComponetScan定位Bean扫描路径
- IOC的创建
  1. 在Spring中BeanFactory就是IOC容器，在Spring初始化的时候，创建容器，并将需要创建对象和对象的关系（xml，注解）通过BeanDefinitionReader加载到BeanDefinition中并保存在BeanDefinitionMap中，在这个过程中会让BeanDefinitionProcesser(Bean的定义信息的后置处理器)进行增强，然后再由IOC容器创建bean对象.
- Bean的生命周期(面试官顺着问题往下问的拓展)
  1. bean的实例化：spring启动后,会查找和加载需要被spring管理的Bean,并且实例化
  2. bean的属性注入(bean的初始化)：bean被实例化后将Bean的引入河值注入到bean的属性中
     - 查看是否调用一些aware接口,比如BeanFactoryAware,BeanFactoryAware,ApplicationContextAware接口,分别会将Bean的名字,BeanFactory容器实例,以及Bean所在用的上下文引用传入给Bean
     - 在初始化之前,会查看是否调用了BeanPostProcessor的预初始化方法,可以对bean进行扩展
     - 调用InitializingBean的afterPropertiesSet()方法：如果Bean实现了InitializingBean接口，spring将调用他们的afterPropertiesSet()方法，类似的，如果Bean使用init-method生命了初始化方法的话，这个方法也会被调用。
     - 初始化成功之后,会查看是否调用BeanPostProcessor的初始化后的方法：如果Bean实现了BeanPostProcessor接口，spring就将调用他们的postprocessAfterInitialization()方法。可以对bean进行扩展
  3. bean的正常使用：可以被应用程序正常使用了,他们将驻留在上下文中,直到应用的上下文被销毁
  4. bean的销毁：调用DisposableBean的destory()方法：如果Bean实现DisposableBean接口，spring将用他的destory()方法，相同的，如果Bean使用了destory-method生命销毁方法，该方法也会被调用。(但由于bean也分为单例和多例,单例bean会随着IOC容器的销毁而销毁,多例的bean不会随着IOC容器的销毁而销毁,他是通过JVM里面的垃圾回收器负责回收)

#### 2.一条 SQL 语句在 MySQL 中的执行过程是怎样的？

简单来说 MySQL 主要分为 Server 层和存储引擎层。Server层主要包括连接器、查询缓存、分析器、优化器、执行器等，还有一个通用binlog日志模块(用于整个数据库操作记录，主从复制的关键)。存储引擎层主要负责数据的存储和读取。

1. 连接器

客户端想要对数据库进行操作时，连接器就是用来负责跟客户端建立连接、获取权限、维持和管理连接的。连接器支持短连接也支持长连接，同时为了避免频繁创建和销毁连接造成性能损失，可选择利用连接池进程管理，如druid，cp30等。

2. 查询缓存(MySQL 8.0 版本后移除)

查询缓存主要用来缓存我们所执行的 select语句以及该语句的结果集。如果开启了查询缓存，执行查询语句的时候，会先查询缓存。如果缓存 key 被命中，就会直接返回给客户端。在数据变换频繁的表中，是不推荐使用的，当一张表的数据发生变化，其所有缓存都将清空。

3. 分析器

分析器的工作主要是对要执行的SQL语句进行解析，最终得到抽象语法树。

4. 优化器

查询优化器会找出执行该语句所有可能使用的方案，然后选择一条最优查询路径，即MySQL认为的效率最高的方式，并生成执行计划。比如你一个表中创建了多个索引，优化器会根据IO和CPU成本，选出代价最小的索引进行执行。

5. 执行器

根据执行计划完成SQL语句的操作，执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。

#### 3.并发和并行有什么区别？同步和异步有什么区别？

并发和并行是两个计算机领域中经常被提到的概念，它们的含义有所不同。

1. 并发（Concurrency）：指的是系统中同时存在多个正在执行的任务，并且这些任务之间可能会相互影响。并发通常用来处理多个任务共享资源的情况。在单核 CPU 上，多个任务会轮流使用 CPU 时间片，表现为看似同时执行的情况，但实际上只有一个任务正在执行。
2. 并行（Parallelism）：指的是系统中同时存在多个并且相互独立的任务，并且这些任务可以在多个处理器上同时执行，真正意义上的同时处理多个任务。
3. 同步（Synchronous）：指的是程序按照代码的顺序执行，一行一行地执行，直到当前行执行完成后才能继续执行下一行。同步通常会阻塞调用者，直到任务完成才能返回。
4. 异步（Asynchronous）：指的是程序在执行某个任务时，不会一直等待任务完成，而是继续执行下一行代码，当任务完成后再进行相应的处理。异步通常不会阻塞调用者，可以提高系统的并发性能。

总的来说，"并发"和"并行"是针对多个任务的执行方式，"同步"和"异步"是针对任务执行的阻塞方式和返回方式。在实际应用中，可以根据不同的需求来选择合适的并发和同步方式，以提高系统的性能和可靠性。

### Day10

#### 1.String 和 StringBuffer、StringBuilder 的区别是什么？

Java中的String和StringBuffer、StringBuilder是三种不同的字符串类型，它们的主要区别在于它们的性能、线程安全性和可变性。

1. String类型是不可变的，一旦创建，其内容就不可更改。每当对String对象进行操作时，都会创建一个新的String对象，并将修改后的结果保存到这个新的String对象中。这个特性使得String对象在频繁修改时会产生大量的中间对象，消耗大量的内存和CPU资源，因此不适合在频繁修改字符串的场景下使用。
2. StringBuffer和StringBuilder都是可变的字符串类型，它们的主要区别在于线程安全性。StringBuffer是线程安全的，所有对它的操作都是同步的，因此适合在多线程环境下使用。StringBuilder是非线程安全的，不具备同步机制，因此适合在单线程环境下使用。除了线程安全性以外，StringBuffer和StringBuilder的API接口都是一样的。

综上，如果需要频繁修改字符串并且考虑到线程安全性，应该使用StringBuffer。如果在单线程环境下频繁修改字符串，可以使用StringBuilder。如果字符串是不需要修改的，应该使用String类型，因为它具备更好的性能和内存使用效率。

#### 2.MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别，为什么 MySQL 要用 B+ 树？

MySQL中的索引采用B+树实现。

B+树是一种多路搜索树，是对B树的一种改进。

B树和B+树的主要区别在于 :

1. B+树只存储数据的索引信息，并且把叶子节点存储在同一层上，中间节点只起到索引作用，查询时只需要遍历一次树就能找到目标数据,因此B+树具有更好的查询性能和更少的磁盘I/O次数，B+树的叶子节点都连接成了一个有序的链表，因此可以很方便地进行范围查询等操作。适合于数据库等存储大量数据的场景。

2. B树是一种平衡树，它的每个节点都存储有序的关键字，并且每个节点的子节点数目介于m/2和m之间。B树中的每个节点既可以存储数据，也可以存储索引信息，因此B树可以减少I/O次数，适合于文件系统等存储大量数据的场景。但是B树的查询性能相对较低，因为每个节点都可能存储数据，查询时需要遍历多个节点才能找到目标数据。

在MySQL中使用B+树作为索引的数据结构，主要是因为B+树的查询性能好、支持范围查询、支持数据分页等操作，适用于存储海量数据的场景。此外，B+树的索引结构相对简单，易于实现和维护，能够满足高并发、高可用性的数据库要求。

#### 3.Spring框架都使用了那些设计模式

Spring 框架中使用了许多设计模式，以下列举一些比较重要的：

1. 单例模式：Spring 的 Bean 默认是单例模式，通过 Spring 容器管理 Bean 的生命周期，保证每个 Bean 只被创建一次，并在整个应用程序中重用。
2. 工厂模式：Spring 使用工厂模式通过 BeanFactory 和 ApplicationContext 创建并管理 Bean 对象。
3. 代理模式：Spring AOP 基于动态代理技术，使用代理模式实现切面编程，提供了对 AOP 编程的支持。
4. 观察者模式：Spring框架中的事件机制就是采用观察者模式，通过注册监听器和发布事件的方式实现对象之间的解耦。
5. 模板方法模式：Spring 中的 JdbcTemplate 使用了模板方法模式，将一些固定的流程封装在父类中，子类只需实现一些抽象方法即可。
6. 适配器（Adapter）模式 ：Spring MVC 框架中的 HandlerAdapter 就是一个适配器模式的实现，它将不同类型的处理器适配成 Spring MVC 可以处理的处理器。
7. 责任链模式：Spring 中的过滤器和拦截器使用了责任链模式，多个过滤器和拦截器按照一定顺序执行，每个过滤器和拦截器可以拦截请求或者响应并做出相应的处理。

总之，Spring 框架中充分利用了许多设计模式，提供了良好的扩展性和灵活性，降低了代码的耦合度，提高了代码的可维护性。

### Day11

#### 1.MySQL 事务有哪些隔离级别、分别有什么特点，以及 MySQL 的默认隔离级别是什么？

MySQL 事务有四种隔离级别：

1. **读未提交**（Read Uncommitted）：事务可以读取未提交的数据，可能会读到脏数据，会导致幻读、不可重复读、脏读等问题；
2. **读已提交**（Read Committed）：只能读取已经提交的数据，可以避免脏读问题，但是可能会遇到不可重复读、幻读问题；
3. **可重复读**（Repeatable Read）：保证同一个事务中多次读取同一数据的结果是一致的，避免了脏读和不可重复读问题，但是可能会遇到幻读问题；
4. **序列化**（Serializable）：最高的隔离级别，可以避免所有并发问题，但是并发性能非常低，开销很大。

MySQL 的默认隔离级别是可重复读（Repeatable Read）。

其中，脏读指一个事务读到了另一个事务未提交的数据，不可重复读指同一个事务多次读取同一数据得到不同结果，幻读指同一个事务前后读取的数据集合不一致。

#### 2.讲一下 Redis 的单线程模型，IO 多路复用是什么？

- Redis 是一个基于内存的键值存储数据库，采用单线程模型来处理客户端请求。这意味着 Redis 服务器只使用一个线程来处理所有的客户端请求，而不是像其他数据库那样使用线程池来并发处理请求。这种单线程模型带来的好处是：

  1. 简单高效：单线程模型避免了多线程间的竞争和上下文切换开销，可以更高效地利用 CPU 和内存资源。
  2. 可靠性高：单线程模型避免了多线程间的竞争和死锁问题，提高了系统的可靠性。
  3. 易于维护：单线程模型简化了 Redis 的代码结构和逻辑，使得系统更易于维护和调试。

  同时，Redis 采用 IO 多路复用技术来实现高效的网络通信。

- IO 多路复用指的是在一个线程中同时监听多个网络连接，可以在一个循环中处理多个请求，从而避免了线程间上下文切换的开销。Redis 使用了 select、epoll 和 kqueue 等 IO 多路复用技术，可以高效地处理大量的并发请求。

#### 3.什么是 BIO、NIO、AIO？

- BIO，全称 Blocking I/O，也称为同步阻塞 I/O。BIO 是最早的 I/O 模型，它是一种阻塞式的 I/O 模型，即当应用程序调用 I/O 操作时，该操作会一直阻塞线程直到操作完成，这会导致 I/O 性能低下。BIO 适用于连接数较小的场景，例如单线程的服务器模型。

  打算约女神，给女神发短信后，没见到女神就一直等在宿舍楼下。

- NIO，全称 Non-Blocking I/O，也称为同步非阻塞 I/O。NIO 是一种同步非阻塞的 I/O 模型，它的核心是 Selector 和 Channel，利用 Selector 监听多个 Channel 上的事件，当一个 Channel 上的事件到达时，它会被 Selector 转发给注册在这个 Selector 上的其他 Channel，这样可以用一个线程来处理多个请求，提高了 I/O 的效率。NIO 适用于连接数多、连接时间短的场景，例如实时聊天室、在线游戏等。

  打算约女神，给女神发短信后，没见到女神就一直发短信。

- AIO，全称 Asynchronous I/O，也称为异步非阻塞 I/O。AIO 是 JDK1.7 引入的 I/O 模型，它的特点是异步处理 I/O 操作，当操作完成时会通知应用程序，相比于 NIO 的同步非阻塞 I/O，AIO 无需通过轮询操作完成状态，从而提高了 I/O 的效率。AIO 适用于连接数多、连接时间长的场景，例如 HTTP 长连接、文件操作等。

  打算约女神，你发完短信，你就去玩游戏了，女神下楼了，发短信给你，你才出现。

### Day12

#### 1.意向锁是什么？有什么作用？它是表级锁还是行级锁？

意向锁是一种 MySQL 数据库中的锁，用于表级锁协调多个行级锁的使用。在表级锁定一个表之前，MySQL 需要先获得一个意向锁，以表明要获取的锁类型（读锁或写锁），避免其他事务锁定整个表或锁定一部分表时引发死锁。

意向锁是一种轻量级锁，它不会影响其他事务的读操作，只有在某个事务要对表进行写操作时才会加上意向锁，而其他事务在读取表时只需要获取读锁，不需要等待意向锁的释放。

意向锁可以提高数据库并发性能，防止死锁的发生。它是表级锁，而不是行级锁。

#### 2.Spring、SpringMVC、SpringBoot 三者之间是什么关系？

Spring、SpringMVC、SpringBoot 是三个独立的框架，它们之间的关系是：

1. Spring 是一个 Java 的轻量级应用框架，提供了基于 IoC 和 AOP 的支持，用于构建企业级应用。Spring 有多个模块，包括 Spring Core、Spring Context、Spring JDBC、Spring Web 等，每个模块提供了不同的功能。
2. SpringMVC 是 Spring 框架的一部分，是基于 MVC 设计模式的 Web 框架，用于构建 Web 应用程序。它提供了控制器、视图解析器、数据绑定、异常处理等功能，使得开发 Web 应用变得更加简单。SpringMVC 还支持 RESTful 架构。
3. SpringBoot 是基于 Spring 框架的一个开发框架，用于快速构建独立的、生产级别的 Spring 应用程序。它通过自动配置和约定优于配置的方式，简化了 Spring 应用程序的配置和开发过程。SpringBoot 集成了很多常用的第三方库和工具，例如 Spring Data、Spring Security、Thymeleaf、Logback 等，可以极大地提高开发效率。

因此，SpringBoot 可以看作是在 Spring 的基础上，通过自动配置和约定优于配置的方式，提供了更加简单、快速的开发体验。而 SpringMVC 则是 Spring 框架中用于构建 Web 应用程序的模块。

#### 3.Redis 基础类型中的 String 底层实现是什么？

Redis 中的 String 类型底层实现是一个简单动态字符串（SDS，Simple Dynamic String），也就是字符串动态增长实现的一种方式。SDS 是 Redis 自己实现的字符串库，相对于 C 语言原生的字符串，SDS 在空间使用上更加灵活，而且支持 O(1) 复杂度的长度计算，避免了 C 语言字符串计算长度时的 O(N) 时空复杂度问题。

SDS 是一种动态字符串，它有如下特点：

1. 首先 SDS 对内存的分配和释放进行了封装，使得字符串的空间可以根据需要进行增长或缩减，避免了 C 语言字符串需要手动分配空间的问题。
2. SDS 除了记录字符串本身的长度外，还记录了分配给字符串的空间的长度，可以方便地计算出字符串是否需要扩容。
3. SDS 使用了惰性空间释放，不会在空间缩减时立即释放空间，而是等到需要扩容时再重新分配内存。
4. SDS 提供了字符串追加操作，可以在 O(1) 的时间内完成追加操作。

在 Redis 中，String 类型并不仅仅只是字符串类型，它还支持一些其他的操作，如递增/递减操作、位运算等，这些操作都是基于 SDS 底层实现的。

### Day13

#### 1.有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？

Spring 内置的 @Autowired 以及 JDK 内置的 @Resource 和 @Inject 都可以用于注入 Bean。

一般在工作中，@Autowired和 @Resource 使用的比较多一些。

- [@Autowired ](https://www.code-nav.cn/Autowired)是 Spring 提供的注解， @Resource 是 JDK 提供的注解。
- Autowired 默认的注⼊⽅式为 byType （根据类型进⾏匹配）， [@Resource ](https://www.code-nav.cn/Resource)默认注⼊⽅式为byName （根据名称进⾏匹配）。
- 当⼀个接⼝存在多个实现类的情况下， [@Autowired ](https://www.code-nav.cn/Autowired)和 [@Resource ](https://www.code-nav.cn/Resource)都需要通过名称才能正确匹配到对应的 Bean。 Autowired 可以通过 [@Qualifier ](https://www.code-nav.cn/Qualifier)注解来显示指定名称， [@Resource ](https://www.code-nav.cn/Resource)可以通过 name 属性来显示指定名称。

#### 2.请你介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？

JVM 内存模型分为以下几个区域：

1. 程序计数器（Program Counter Register）：每个线程都有自己的程序计数器，用于指示当前线程执行的字节码指令的行号，以便线程执行时能够回到正确的位置。
2. 虚拟机栈（JVM Stack）：也称为 Java 方法栈，用于存储方法执行时的局部变量表、操作数栈、动态链接、方法出口等信息。每个线程在执行一个方法时，都会为该方法分配一个栈帧，并将该栈帧压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈。
3. 本地方法栈（Native Method Stack）：与虚拟机栈类似，用于存储本地方法的执行信息。
4. 堆（Heap）：用于存储对象实例，是 JVM 中最大的一块内存区域。堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，堆中存储的对象实例都有一个标记用于标记对象是否存活。垃圾回收器会周期性地回收那些没有被标记为存活的对象。
5. 方法区（Method Area）：用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也是被所有线程共享的。
6. 运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用，这些内容在类加载后进入常量池中。

其中，程序计数器、虚拟机栈、本地方法栈是线程私有的，堆、方法区、运行时常量池是线程共享的。

#### 3.Linux 中的硬链接和软连接是什么，二者有什么区别？

- 在 Linux 文件系统中，硬链接（hard link）和软链接（symbolic link）都是一种文件链接的方式，可以用于将一个文件链接到另一个文件上。它们的主要区别在于创建方式、所占空间和使用限制等方面。
- 硬链接是通过在文件系统中创建一个新的目录项（directory entry）指向同一文件 inode 的位置来实现的。因为硬链接实际上是指向同一 inode，所以如果原文件被删除，硬链接依然能够访问到原文件的内容。硬链接的使用范围比较受限，因为硬链接只能指向同一个文件系统内的文件，不能跨文件系统创建。
- 软链接是通过在文件系统中创建一个新的文件来实现的，该文件中包含指向另一个文件的路径。软链接可以跨文件系统创建，并且可以指向任何类型的文件。但是，当原文件被删除时，软链接将会失效。
- 总的来说，硬链接更加高效，因为它只是添加了一个新的目录项，所以对磁盘空间的消耗比软链接要小。但是，硬链接不能跨文件系统，所以在实际应用中需要根据具体的需求来选择使用哪种链接方式。

### Day14

#### 1.如何使用 Redis 实现一个排行榜？

Redis实现排行榜是Redis中一个很常见的场景，主要使用的是ZSet进行实现，下面是为什么选用ZSet：

- 有序性：排行榜肯定需要实现一个排序的功能，在Redis中有序的数据结构有List和ZSet；
- 支持分数操作：ZSet可以对集合中的元素进行增删改查操作，十分贴合排行榜中用户分数动态变化的场景，而List并不能针对分数进行操作，只有其中的value进行操作；
- 支持范围查询：ZSet可以按照分数进行范围查询，如排行榜中的Top10需求就可通过该特性进行实现；
- 支持去重：由于ZSet属于Set的特殊数据结构，因此同样拥有Set不可重复的特性，对于排行榜中不可出现重复项的需求也十分贴合，而List只能手动去重。

因此选择ZSet实现排行榜相对于List实现会更合适和高效。

> 以学生成绩排行为例，下面是使用Redis命令实现

```apache
# 添加示例数据
ZADD scores 90 "张三"
ZADD scores 85 "李四"
ZADD scores 95 "王五"
ZADD scores 92 "赵六"
# 查询排名前3的学生信息
ZRANGE scores 0 2 WITHSCORES
# 查询排名前3的打印
1) "王五"
2) "95"
3) "赵六"
4) "92"
5) "张三"
6) "90"
# 删除学生“李四”的成绩信息
ZREM scores "李四"
```

> 下面是SpringBoot整合Redis进行实现

```java
// 添加学生成绩
public void addScore(String name, int score) {
    redisTemplate.opsForZSet().add("scores", name, score);
}

// 查询排名前N的学生成绩
public List<Map.Entry<String, Double>> getTopScores(int n) {
    return redisTemplate.opsForZSet().reverseRangeWithScores("scores", 0, n - 1)
            .stream()
            .map(tuple -> new AbstractMap.SimpleEntry<>(tuple.getValue(), tuple.getScore()))
            .collect(Collectors.toList());
}

// 删除某个学生的成绩
public void removeScore(String name) {
    redisTemplate.opsForZSet().remove("scores", name);
}
```

#### 2.什么是网关，网关有哪些作用？

网关，即Gateway，网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求。如果让客户端直接与各个微服务通信，会有以下的问题：

- 客户端会多次请求不同的微服务，增加了客户端的复杂性；
- 存在跨域请求，在一定场景下处理相对复杂；
- 认证复杂，每个服务都需要独立认证；
- 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。而划分出多个微服务就代表可能出现多个新的访问地址，如果客户端直接与微服务通信，那么重构将会很难实施；
- 某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定的困难；

那么使用网关的好处就如下：

- 统一路由
- 负载均衡
- 统一鉴权
- 解决跨域跨域
- 统一业务处理
- 接口保护

常见的网关产品有Tyk，Kong，Zuul以及Spring Cloud Gateway

#### 3.线程的生命周期是什么，线程有几种状态，什么是上下文切换？

线程的生命周期通常包括五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和终止（Terminated）。其中：

- 新建状态是指当线程对象创建后，就进入了新建状态。此时它已经有了相应的内存空间和其他资源，但还没有开始运行。
- 就绪状态是指当线程对象调用 start() 方法后，线程进入了就绪状态。此时它已经具备了运行的条件，只等 CPU 分配资源，让其开始执行。
- 运行状态是指当线程对象获得 CPU 资源后，就开始执行 run() 方法中的代码，线程处于运行状态。
- 阻塞状态是指线程在某些特定情况下会被挂起，暂时停止执行。当线程处于阻塞状态时，它并不会占用 CPU 资源。
- 终止状态是指当线程的 run() 方法执行完毕或者因异常退出时，线程进入了终止状态。此时，该线程不再占用 CPU 资源，也不再执行任何代码。

在线程的生命周期中，线程状态的转换通常是由操作系统调度和控制的。当线程的状态发生变化时，需要进行上下文切换，即将当前线程的状态保存下来，并将CPU资源切换到另一个线程上运行的过程。上下文切换需要花费一定的时间和系统资源，因此，线程的上下文切换次数要尽量减少，以提高系统的性能。

### Day15

#### 1.MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？

MVCC 是指多版本并发控制（Multiversion Concurrency Control），是一种并发控制机制，常用于数据库系统中，用于实现事务的并发控制。它允许在同一时间多个事务对同一个数据集合进行读取操作，同时防止数据不一致和其他并发问题。

InnoDB 是 MySQL 中最常用的存储引擎之一，它的 MVCC 实现是通过在每行记录中添加两个隐藏的列，分别记录行的创建时间和过期时间，以此来判断事务对该行记录的可见性。当一个事务需要读取一行记录时，InnoDB 首先读取这行记录的创建时间和过期时间，并根据这些信息判断该行记录是否可见。如果创建时间早于当前事务的开始时间，且过期时间晚于当前事务的开始时间，那么该行记录对当前事务可见。

在 InnoDB 中，MVCC 主要是通过实现以下几个机制来实现的：

1. 事务版本号：每个事务都有一个唯一的版本号，用来标识该事务的创建时间。
2. 读取视图：每个事务在开始时都会创建一个读取视图，记录该事务开始时间和其他信息。在事务执行期间，所有读取操作都要检查该视图，以确定读取哪些版本的数据。
3. undo 日志：在事务执行期间，如果对数据进行修改，那么会先将原始数据复制一份到 undo 日志中。这样，在回滚操作时就可以使用 undo 日志中的数据来还原原始数据。
4. 快照读取：在某些情况下，事务需要读取一个数据的历史版本，而不是当前版本。这时可以使用快照读取来实现，即在读取时根据事务开始时间和 undo 日志来读取历史版本的数据。

#### 2.Redis 的持久化机制有哪些？说说各自的优缺点和应用场景？

Redis 的持久化机制主要有两种：RDB（Redis Database）和 AOF（Append Only File）。

​	**1、RDB 持久化**
​	RDB 持久化机制会在指定的时间间隔内对数据集做快照，将快照存储到磁盘中。

​	**RDB 的优缺点：**对于数据恢复速度比较快，同时存储的文件也比 AOF 小，缺点是可能会出现数据丢失的情况，因为快照的时间间隔越长，数据丢失的可能性就越大。

​	**2、AOF 持久化**
​	AOF 持久化机制则会将每一次的写操作都追加到一个文件中，这个文件就是 AOF 文件。AOF 文件保存了 Redis 服务器接收到的所有写命令，当 Redis 重启时，就可以使用 AOF 文件重建数据集。

​	**AOF 的优缺点：**数据丢失的可能性比 RDB 低，缺点是文件比 RDB 大，恢复速度比较慢。

​	**3、RDB + AOF 混合使用**

​	除了 RDB 和 AOF 外，Redis 还支持混合持久化机制，即同时使用 RDB 和 AOF 两种持久化机制，以此来发挥它们的优点。这里的 AOF 日志不再是全量 的日志，而是 RDB 久 化开始 到 RDB 持久化结束的这段时间发生的增量 AOF 日志。

**应用场景：**

- RDB 适合用于数据集比较大，数据恢复速度比较快的场景，例如备份、灾难恢复等；
- AOF 适合用于数据集比较小，数据完整性比较重要的场景，例如金融、电商等行业。

#### 3.Nginx 是什么？它有哪些应用场景？

Nginx 是一个高性能、开源、反向代理服务器，也可以用作负载均衡器、HTTP 缓存、Web 服务器和作为邮件代理服务器。它最初是为了解决 C10K（每秒并发连接数超过一万）问题而开发的，能够支持高并发和高可扩展性。

Nginx 的应用场景包括：

1.反向代理：Nginx 可以作为反向代理服务器，将客户端的请求转发给后端的服务器进行处理，并将处理结果返回给客户端。这种模式可以提高应用程序的安全性和可靠性，以及提高应用程序的性能和扩展性。

2.负载均衡：Nginx 可以作为负载均衡器，将客户端请求均衡地分配到多个后端服务器上进行处理，从而提高系统的可用性和吞吐量。负载均衡器可以根据不同的策略进行负载均衡，例如轮询、IP 地址哈希、最少连接数等。

3.HTTP 缓存：Nginx 可以作为 HTTP 缓存服务器，缓存静态文件和动态页面，从而减轻后端服务器的负担，提高系统的性能和响应速度。

4.Web 服务器：Nginx 可以作为 Web 服务器，直接提供静态文件服务和动态页面服务，也可以与其他 Web 服务器进行集成，提高系统的可靠性和性能。

5.作为邮件代理服务器：Nginx 还可以作为邮件代理服务器，处理 SMTP、POP3 和 IMAP 协议，提高邮件服务器的性能和可靠性。

### Day16

#### 1.synchronized 关键字是什么，有什么作用？

- synchronized 

  `synchronized` 是 Java 中的一个关键字，用于实现线程同步。具体来说，`synchronized` 用于修饰方法或代码块，使得同一时刻只能有一个线程访问被修饰的代码，其他线程需要等待当前线程执行完毕后才能访问。

- 作用

  `synchronized` 主要用于解决多线程并发访问共享资源时出现的线程安全问题。如果多个线程同时访问一个共享资源，就会出现多个线程同时修改这个资源的情况，从而导致数据不一致等问题。而使用 `synchronized` 可以保证同一时刻只有一个线程访问该资源，从而避免了线程安全问题。

  - `synchronized` 的作用不仅限于线程同步，它还可以保证可见性和有序性，即保证在同一个锁上，一个线程修改了共享变量的值之后，另一个线程能够立即看到修改后的值，并且在多个线程执行顺序上保证了一致性。
  - 需要注意的是，使用 `synchronized` 会带来一定的性能损失，因为每次进入同步块时都需要获得锁，这会增加线程的等待时间和上下文切换的开销。同时，如果同步块的代码执行时间很短，也会增加不必要的性能开销。因此，需要根据具体情况来判断是否需要使用 `synchronized`。

#### 2.Dubbo 是什么？是否了解过它的架构设计？

- Dubbo是一个高性能、轻量级的开源Java RPC框架，它提供了完整的RPC协议栈，包括服务发布、服务引用、负载均衡、容错、服务治理和服务监控等功能，同时提供了可扩展的RPC协议、数据模型、序列化和网络传输等组件，支持多语言和多协议。
- Dubbo的架构设计主要包括服务提供者、服务消费者、注册中心和监控中心四个角色。其中，服务提供者提供服务的实现，并通过注册中心将自己注册到服务治理中心；服务消费者则通过注册中心发现可用的服务，并通过负载均衡策略选择一个服务提供者进行调用；注册中心主要负责服务的注册、发现和路由；监控中心则负责服务的统计和监控。
- Dubbo的架构设计采用了分层架构模式，将不同的功能模块进行分离，以达到模块化和可扩展的目的。同时，Dubbo还提供了丰富的扩展点和插件机制，用户可以通过自定义扩展点和插件来满足不同的业务需求。
- **什么是RPC？**
  RPC全称为remote procedure call，即**远程过程调用**。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。

#### 3.如何设计一个点赞系统？

1. 数据库设计：需要设计一个点赞记录表，记录用户和点赞对象的关系，包括用户ID、点赞对象ID、点赞时间等字段。可以考虑使用关系型数据库或者NoSQL数据库来存储这些信息。
2. 缓存设计：点赞记录较多，可以考虑使用缓存来提高读写性能。可以使用Redis等内存型数据库或缓存系统来存储热点点赞记录。
3. 接口设计：需要设计接口来处理点赞操作。可以设计一个点赞接口，接收用户ID和点赞对象ID作为参数，然后根据这些参数，在点赞记录表中添加一条点赞记录。同时，也需要设计一个取消点赞接口，接收用户ID和点赞对象ID作为参数，然后在点赞记录表中删除对应的点赞记录。
4. 安全性设计：需要对点赞接口进行安全性设计，防止恶意请求或重复点赞。可以使用防重复提交、接口加密等方式来增加接口的安全性。
5. 统计与展示：需要设计统计和展示点赞数的接口。可以设计一个获取点赞数接口，接收点赞对象ID作为参数，然后根据该参数在点赞记录表中查询该点赞对象的点赞记录数，并返回给调用者。同时，也可以在点赞对象页面上展示点赞数，用于用户的查看和参考。

### Day17

#### 1.什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？

内部类是定义在另一个类中的类。Java中内部类主要分为成员内部类、静态内部类、局部内部类和匿名内部类四种。

1. 成员内部类：定义在另一个类的内部，并且与其它成员变量和方法平级，可以访问外部类的所有成员变量和方法。使用方式：Outer.Inner inner = new Outer().new Inner()。
2. 静态内部类：定义在另一个类的内部，但是要用 static 修饰。只能访问外部类的静态成员变量和方法。使用方式：Outer.Inner inner = new Outer.Inner()。
3. 局部内部类：定义在方法中，作用域仅限于方法内部。与局部变量类似，不能使用访问控制符修饰。使用方式：在方法中直接实例化。
4. 匿名内部类：没有名字的内部类。使用方式：new 接口或者抽象类() { } 或 new 父类() { }。

内部类的优点：

1. 可以访问外部类的私有成员变量和方法。
2. 可以隐藏实现细节。
3. 便于编写和维护，提高代码的可读性和可维护性。
4. 内部类可以很好地解决Java中单继承的问题。

内部类的应用场景：

1. 需要访问外部类的私有成员变量和方法。
2. 需要定义一个回调函数或者监听器。
3. 需要实现多重继承。
4. 需要对外部类进行扩展。

#### 2.覆盖索引和联合索引是什么？讲一下索引的最左前缀匹配原则。

- 覆盖索引和联合索引是数据库中常见的两种索引类型。
- 覆盖索引是指一个包含了所有查询需要的列的索引，查询时可以直接从索引中取到需要的数据，而不需要再回到表中查找，从而可以提高查询效率。
- 联合索引是指使用多个列组合起来作为一个索引，可以同时查询多个列，以提高查询效率。联合索引可以包含多个列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索引的前几个列，才能利用联合索引进行查询。如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描。
- 最左前缀匹配原则是指如果一个联合索引包含了多个列，那么在查询时只能使用前面的列进行匹配。例如，一个联合索引包含了 A、B、C 三列，那么查询时只能使用 A、AB 或 ABC 进行匹配，而不能只使用 B 或 C 进行匹配。这是因为如果查询时使用的列不是最左前缀列，那么 MySQL 就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。
- 在实际的应用中，覆盖索引和联合索引可以结合使用，以提高查询效率。同时，使用最左前缀匹配原则可以让我们更加合理地设计索引，从而提高查询性能。

#### 3.Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？

**Spring 如何处理线程并发问题？**

Spring 中处理线程并发问题的主要方式是**使用线程安全的对象**和**并发包中提供的类**来避免线程安全问题。

例如，Spring 中的单例 Bean 是线程安全的，因为 Spring 容器在创建单例 Bean 时会确保只有一个实例存在。Spring 还提供了对多线程的支持，例如使用 @Async 注解实现异步方法调用等。



在 Spring 中处理线程并发问题，常用的方法有以下几种：

1. Synchronized关键字：使用 synchronized 关键字可以锁定某个对象或类，使得多个线程无法同时进入该代码块，从而保证数据的安全性。
2. ReentrantLock：与 synchronized 相比，ReentrantLock 提供了更加灵活的加锁方式，可以控制锁的获取和释放的时机，提供了更多的扩展功能。
3. Atomic 包：Java 的 Atomic 包提供了一些原子性操作，例如 AtomicLong、AtomicInteger 等，可以保证某个操作的原子性。
4. ThreadLocal：ThreadLocal 可以使得每个线程拥有自己的变量副本，避免了多个线程之间共享变量所带来的线程安全问题。

**ThreadLocal 你了解过吗？**

- ThreadLocal 是 Java 中的一个线程局部变量，它可以为每个线程提供一个独立的变量副本，避免了多线程之间的数据共享和数据竞争问题。
- ThreadLocal 可以在每个线程中存储一个对象，并且每个线程只能访问自己的对象，而不会影响其他线程中的对象。
- ThreadLocal 主要用于解决线程安全问题，例如在 Web 应用中，可以使用 ThreadLocal 存储用户的会话信息，这样每个线程就可以独立地访问自己的会话信息，避免了多个线程之间的数据共享和数据竞争问题。
- 在 Spring 中，ThreadLocal 通常用于存储和传递一些与线程相关的上下文信息，例如当前登录用户的信息、请求的 IP 地址等。可以将 ThreadLocal 对象定义为一个 Bean，然后在需要使用时注入到其他 Bean 中使用。
- Spring 还提供了一些与 ThreadLocal 相关的类和工具，例如 SimpleThreadScope，用于实现线程范围内的 Bean，以及 TaskExecutor，用于在多线程环境中执行任务。

### Day18

#### 1.什么是 MySQL 执行计划？如何获取执行计划并对其进行分析？

ySQL 执行计划是指 MySQL 查询优化器生成的一份详细的查询执行计划，它展示了 MySQL 在执行查询时所采取的具体执行计划，包括表的访问顺序、数据读取方式、使用的索引、使用的排序方式等等。通过分析执行计划，可以帮助我们找出查询性能瓶颈所在，进而进行优化，提高查询效率。

要获取执行计划，可以在执行 SQL 语句时在前面添加 explain 关键字，例如：

```pgsql
explain select * from table where id = 1;
```

这样，MySQL 会输出该查询语句的执行计划。 执行计划中的各个字段含义如下：

- id：每个 Select 子句或者是一个操作符或者是一个查询语句。
- select_type：查询类型，表示查询的类型（简单查询、联合查询、子查询等等）。
- table：查询涉及的表。
- partitions：匹配的分区。
- type：访问类型，表示 MySQL 在表中找到所需行的方式。
- possible_keys：表示查询可能使用到的索引。
- key：实际使用到的索引。
- key_len：使用的索引长度。
- ref：列与索引的比较。
- rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。
- filtered：返回结果的行数占总行数的比例。
- Extra ★：有关查询执行的其他信息
  - using index：使用覆盖索引，不用回表查询
  - using where：使用 where 子句来过滤结果集
  - using temporary：使用到临时表来存储中间结果，可能会导致性能问题
  - using filesort：查询需要进行文件排序操作，可能会导致性能问题
  - using index condition：先根据能用索引的条件获取符合条件的数据行，然后在根据其他条件去过滤数据

#### 2.什么是单例模式？使用单例模式有什么好处？有哪些常用的单例模式实现方式？各自的应用场景是什么？

单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式的目的是确保类的一个唯一实例，因此其他类可以轻松地从一个可知的地方访问它。



单例模式有以下好处：

1. 节省系统资源：在系统中，如果有多个实例会造成资源浪费，而使用单例模式可以减少这种浪费。
2. 简化了对象访问：单例模式提供了一个全局的访问点，因此可以简化访问过程。



常用的单例模式实现方式有以下几种：

1. 饿汉式单例模式：在类加载时创建单例对象。缺点是不支持延迟加载。
2. 懒汉式单例模式：在第一次使用时才创建单例对象。缺点是需要考虑线程安全问题。
3. 双重检查锁单例模式：在第一次使用时创建单例对象，并使用双重检查锁定来确保线程安全。
4. 枚举单例模式：在枚举类型中创建单例对象，可以防止反射和序列化攻击。


应用场景：

1. 数据库连接池：通过单例模式，可以确保系统中只有一个数据库连接池。
2. 日志记录器：可以使用单例模式记录系统日志，这样可以确保系统中只有一个日志记录器。
3. 配置文件管理器：可以使用单例模式来管理应用程序的配置文件，这样可以避免重复读取配置文件的开销。
4. 线程池：可以使用单例模式来确保系统中只有一个线程池。

一个例子是 Spring 框架中的 ApplicationContext，它是一个全局访问点，提供了一个管理 Bean 的中央注册表。由于 Spring 中的 Bean 只需创建一次，因此 ApplicationContext 使用单例模式确保只有一个实例。

#### 3.什么是云原生？它有哪些优缺点？

云原生是一种开发和运行应用程序的方法，旨在利用云计算的弹性、可扩展性、可靠性和高可用性等优势。它通过将应用程序打包到容器中，使用容器编排工具进行管理，实现了应用程序在不同环境中的快速部署、弹性伸缩和高可用性。



云原生的优点包括：

1. 灵活性和可扩展性：容器可以快速部署和扩展，以满足不同的负载要求。
2. 高可用性：容器编排工具可以自动检测和恢复容器故障，提供高可用性。
3. 效率和成本优化：使用容器可以节省资源和成本，提高应用程序的运行效率。
4. 安全性：容器隔离应用程序的运行环境，减少了安全漏洞的风险。



云原生的缺点包括：

1. 学习曲线较陡峭：云原生技术较为复杂，需要学习一些新的技术和工具。
2. 可能存在依赖问题：应用程序可能依赖于某些特定的云原生技术或工具，这可能导致一些限制或局限性。
3. 管理和维护难度：容器编排工具可能需要额外的管理和维护，需要更多的操作和维护成本。



云原生的应用场景包括：

1. 微服务架构：云原生技术非常适合构建微服务架构，将应用程序拆分为小型、自治的服务。
2. 弹性伸缩：云原生技术可以根据应用程序的负载自动扩展或缩小容器的数量，以适应不同的负载要求。
3. 快速部署：使用云原生技术，可以快速地部署和更新应用程序，提高开发和部署效率。
4. 多云部署：云原生技术可以在多个云环境中运行，方便应用程序在不同云环境中的部署和迁移。
5. 数据处理和分析：云原生技术可以处理大规模的数据处理和分析任务，提高数据处理效率。

### Day19

#### 1.TCP 和 UDP 协议有什么区别，分别适用于什么场景？

TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常用的传输层协议，它们有以下的区别：

1、**连接方面**

TCP 是面向连接的协议，而 UDP 是无连接的协议。在 TCP 中，发送方和接收方必须先建立连接，然后才能传输数据。UDP 则不需要建立连接，直接发送数据即可。

2、**可靠性**

TCP 保证数据传输的可靠性，通过序列号、确认应答和重传机制等方式来保证数据的完整性和正确性。UDP 则不保证数据传输的可靠性，因为它不提供确认和重传机制。

3、**传输速度**

因为 TCP 要保证数据传输的可靠性，所以在传输速度方面相对较慢。而 UDP 则不需要进行复杂的传输控制，因此传输速度更快。

4、**传输内容**

TCP 是一种面向字节流的协议，将数据看作是一连串的字节流，没有明确的消息边界。UDP 则是面向报文的协议，将数据看作是一系列的报文，每个报文是一个独立的单元，具有明确的消息边界。

基于以上的特点，TCP 和 UDP 适用于不同的场景。TCP 适用于对传输可靠性要求比较高的场景，例如网页浏览、文件传输、邮件等。而 UDP 则适用于对传输可靠性要求较低、传输速度要求较高的场景，例如在线游戏、视频直播等。

#### 2.什么是分布式的 CAP 理论？

- 分布式的 CAP 理论是指在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个指标无法同时满足的问题。具体来说：

  - **一致性**（Consistency）：指多个副本之间数据保持一致，即在一个副本上的写操作会立即同步到其他所有副本，所有副本的数据都是最新的，保持强一致性。
  - **可用性**（Availability）：指系统在任何时候都能对外提供服务，即系统随时能够响应用户请求，不会因为节点故障或其他原因而导致服务中断。
  - **分区容错性**（Partition Tolerance）：指系统在出现网络分区（节点之间失去联系）时，仍能够继续工作，保证数据的一致性和可用性。

- CAP 理论指出，一个分布式系统只能同时满足其中的两个指标，无法同时满足三个。例如，当出现网络分区时，如果要保证一致性，就必须停止对外服务，从而失去可用性；如果要保证可用性，就必须放弃一致性，从而可能导致不同节点之间数据不一致。因此，在设计分布式系统时，需要根据具体的场景和需求来选择合适的权衡方案，比如选择 CP（一致性和分区容错性）或者选择 AP（可用性和分区容错性）。

  需要注意的是，CAP 理论只是一种理论框架，不能直接应用于实际的分布式系统设计。在实际应用中，还需要考虑系统的具体业务需求、数据访问模式、节点规模和部署环境等因素，综合权衡之后再选择合适的分布式架构和技术方案。

#### Base理论

-   BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

   [参考](https://zhuanlan.zhihu.com/p/508935801)

#### 3.如何用 Redis 实现分布式 Session？

在分布式系统中，通常会将 Session 存储在 Redis 中来实现分布式 Session，这样就可以在多台服务器之间共享 Session 数据。实现分布式 Session 的方式有多种，其中一种常用的方式是使用 Redis 的数据结构 Hash。具体实现步骤如下：

1. 在用户登录成功后，将 Session 数据存储在 Redis 中。
2. 将 Redis 中的 Session 数据的 Key 设置为一个全局唯一的 ID，一般使用类似于“session:token”这样的格式，其中 token 是一个随机生成的字符串，用来标识这个 Session 数据。
3. 在客户端返回响应的同时，将 Session ID（即 token）以 Cookie 的形式返回给客户端。客户端在后续的请求中都会携带这个 Cookie。
4. 在后续的请求中，服务器会从客户端传递过来的 Cookie 中获取 Session ID，然后根据这个 ID 从 Redis 中获取对应的 Session 数据。如果 Redis 中没有找到对应的 Session 数据，那么就表示这个请求无法通过认证。
5. 在用户退出登录或 Session 失效时，需要将 Redis 中的对应 Session 数据删除。

可以使用 Redis 的 EXPIRE 命令来设置 Session 数据的过期时间，这样可以自动删除已经过期的 Session 数据。同时，还需要注意保护 Redis 中的 Session 数据不被恶意攻击者窃取，一般可以通过设置 Session 数据的前缀和使用随机的 Session ID 等方式来提高安全性。

[参考](https://www.code-nav.cn/post/1633839420715098114)

### Day20

#### 1.MySQL 支持哪些存储引擎？默认使用哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？

**支持的存储引擎：**

- InnoDB

  InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，InnoDB是默认的MySQL存储引擎。它的特点是，支持事务、行级锁、外键约束

- MyISM

  不支持事务和行级锁，但具有较高的性能，适用于读写比例低的应用，如数据仓库、日志系统等。

- Memory

  Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。特点是内存存放，默认是hash索引

- **MyISAM和InnoDB是MySQL中两种不同的存储引擎，它们有以下主要区别：**

  1. 事务支持：MyISAM不支持事务，而InnoDB支持事务。这意味着InnoDB可以保证数据的完整性和一致性，而MyISAM不行。
  2. 锁级别：MyISAM使用表级锁定，这意味着在一个表中的任何更改都会锁定整个表，而InnoDB使用行级锁定，这意味着只有被修改的行会被锁定。因此，InnoDB可以更好地处理并发性。
  3. 外键支持：MyISAM不支持外键约束，而InnoDB支持。外键约束可以确保数据的引用完整性，防止数据的不一致。
  4. 性能：MyISAM对于读密集型应用程序具有很高的性能，而InnoDB对于读写混合型应用程序具有更好的性能。InnoDB相对于MyISAM可能会有更多的开销，但是，它的功能更强大，可以提供更好的数据保护和安全性。
  5. 索引：MyISAM和InnoDB在索引的实现方式上也有所不同。MyISAM使用B-tree索引，而InnoDB使用B+tree索引。

  如果应用程序主要是读操作，那么MyISAM可能是更好的选择，因为它在读取数据时具有更高的性能。如果应用程序需要支持事务、外键约束和高并发性，那么InnoDB可能是更好的选择，因为它可以提供更好的数据完整性和一致性，以及更好的并发控制。

#### 2.Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？

在 Spring 中，BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，它们的区别和联系如下。

区别：

1. BeanFactory 是 Spring 框架的基础设施，用于管理 Bean 的生命周期和依赖关系，提供了 IoC 和 DI 功能。ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能，例如国际化支持、AOP 支持等。
2. BeanFactory 是延迟加载的，即只有在获取 Bean 时才会进行实例化，可以减少系统资源的占用。而 ApplicationContext 在启动时会立即加载所有的 Bean，导致启动时间较长。
3. BeanFactory 是单例模式，即在整个应用中只有一个 BeanFactory 实例。而 ApplicationContext 可以有多个实例，并且可以通过父子容器的方式组织起来，方便模块化开发。

联系：

1. BeanFactory 和 ApplicationContext 都是用于管理 Spring Bean 的容器，可以管理 Bean 的生命周期和依赖关系，提供了 IoC 和 DI 功能。
2. ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能，例如国际化支持、AOP 支持等，同时也支持 BeanFactory 的所有功能。
3. BeanFactory 和 ApplicationContext 都可以通过 XML 配置文件、Java 注解和 Java 代码等方式进行配置和管理。
4. BeanFactory 和 ApplicationContext 都可以管理单例 Bean 和原型 Bean，可以控制 Bean 的作用域和生命周期。

总结：BeanFactory 是 Spring 框架的基础设施，提供了 IoC 和 DI 功能，而 ApplicationContext 是 BeanFactory 的扩展，提供了更多的功能和扩展性，可以通过多种方式进行配置和管理 Spring Bean。

#### 3.讲一下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？

Redis中的淘汰机制：

1. 定时扫描：定时扫描Redis中的key，发现过期的就删除。
2. 惰性删除：key过期不会立即删除，在访问key的时候，判断该key是否过期，如果过期就删除。
3. 内存淘汰策略：当 Redis 内存占用达到上限时，会根据内存淘汰策略来选择一些键进行删除，以腾出更多的内存空间。

内存淘汰策略：

1. volatile-lru（least recently used）：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
4. allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
2. allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

### Day21

#### 1.Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使用多线程？

在 Redis 6.0 之前，Redis 是单线程的，这是因为 Redis 的主要瓶颈是在 CPU 上。但是随着硬件的发展，现代服务器的 CPU 核心数已经达到了几十个，这就导致 Redis 单线程模型无法充分利用多核处理器的性能。因此，Redis 6.0 引入了多线程，以提高 Redis 在多核处理器上的性能。

Redis 6.0 之前为什么不使用多线程，主要有以下几个原因：

1. Redis 单线程模型相对简单，容易维护和调试，代码逻辑也比较清晰。
2. Redis 的主要瓶颈在于 CPU，而不是 I/O，因此采用多线程模型并不能显著提高性能。
3. Redis 是一个内存型数据库，它的性能主要受到 CPU 和内存带宽的限制。采用多线程模型会增加线程之间的竞争和锁等开销，反而可能降低 Redis 的性能。

但是随着硬件的发展，多核处理器已经成为了现代服务器的标配，因此 Redis 引入多线程的举措可以更好地发挥硬件的性能，提高 Redis 的吞吐量和响应速度。

Redis 6.0 引入多线程后，采用了多种技术手段来实现多线程操作的安全和稳定性，如使用**锁**和**原子操作**来保证数据一致性和线程安全。

需要注意的是：

- Redis 6.0 中的多线程并不是完全替代了单线程模型，而是在其基础上引入了多线程支持，通过将一些负载耗时的操作（如I/O操作）交给后台线程处理，从而提高Redis的性能。同时，在多线程模式下，Redis仍然保留了所有的单线程模式特性，如ACID事务等。
- Redis 6.0 中多线程的使用是可选的，并且可以通过配置文件进行启用或禁用，以便在不同的应用场景下选择最适合的运行模式。

#### 2.HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？

HTTP 协议中 GET 和 POST 是两种常用的请求方法，它们的区别如下：

1. 参数传递方式不同 GET 请求参数是在 URL 中以键值对的形式传递的，例如：http://www.example.com/?key1=value1&key2=value2。 而 POST 请求参数是在请求体中以键值对的形式传递的。
2. 参数传递大小不同 GET 请求参数有大小限制，因为 URL 长度有限制，不同的浏览器和服务器对 URL 长度的限制不同，一般为 2048 个字符。而 POST 请求参数没有大小限制，因为它们是以请求体的形式传递的。
3. 安全性不同 GET 请求的参数是明文传输的，因为参数在 URL 中，如果涉及敏感信息（如密码），容易被窃取或暴露在浏览器历史记录、代理服务器日志等地方。而 POST 请求的参数在请求体中传输，相对安全一些，但是也需要注意参数加密和防止 CSRF 攻击等问题。

GET 和 POST 适用的场景不同：

1. GET 请求适用于获取数据，如浏览网页、搜索等。因为 GET 请求参数以明文形式传输，容易被拦截和篡改，所以不适用于提交敏感信息的操作。
2. POST 请求适用于提交数据，如登录、注册、发布内容等。因为 POST 请求参数在请求体中传输，相对安全一些，可以提交敏感信息，但是需要注意参数加密和防止 CSRF 攻击等问题。

#### 3.什么是零拷贝？说一说你对零拷贝的理解？

零拷贝（Zero-copy）是一种高效的数据传输机制，在追求低延迟的传输场景中十分常用。它是一种 I/O 操作优化技术，指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。传统的数据传输方法需要将数据从一个缓冲区拷贝到另一个缓冲区，而零拷贝技术可以直接在内核空间中完成数据传输，避免了数据复制的过程，从而提高了数据传输的效率。

在传统的数据传输方法中，数据需要经过多次复制才能到达目标缓冲区，这个过程包含了用户空间和内核空间之间的多次上下文切换，这些上下文切换会导致系统的性能下降。而零拷贝技术可以避免这些上下文切换，从而提高了系统的性能。例如，当应用程序需要将大量的数据写入到磁盘或者网络中时，使用零拷贝技术可以减少数据复制的过程，提高数据传输的效率。

零拷贝技术的实现主要有以下几种方式：

- 文件描述符传递：通过文件描述符的传递，将数据从一个进程传递到另一个进程，避免了数据复制的过程。
- sendfile()函数：在Linux系统中，sendfile()函数可以将一个文件描述符指向的文件内容直接传输到一个socket文件描述符中，避免了数据复制的过程。
- mmap()函数：mmap()函数可以将一个文件映射到内存中，避免了数据复制的过程。

总之，零拷贝是一种高效的数据传输机制，在追求低延迟的传输场景中应用广泛。使用零拷贝技术可以避免数据复制的过程，减少上下文切换，提高系统的性能。

### Day22

#### 1.什么是 RPC？目前有哪些常见的 RPC 框架？实现 RPC 框架的核心原理是什么？

- RPC（Remote Procedure Call）是一种远程调用协议，允许一台计算机通过网络调用另一台计算机上的服务或方法。它可以让开发人员像调用本地方法一样调用远程方法，将网络通信细节封装起来，提高了分布式系统中各个模块之间的耦合性。
- 目前常见的 RPC 框架有：

1. Dubbo：阿里巴巴开源的分布式 RPC 框架，支持多种协议和负载均衡策略。
2. gRPC：Google 开源的高性能 RPC 框架，支持多种语言。
3. Thrift：Facebook 开源的跨语言 RPC 框架，支持多种传输协议和数据编解码方式。
4. Spring Cloud Netflix：Spring Cloud 的子项目之一，提供了基于 Netflix OSS 开源组件的微服务解决方案，包括服务发现、负载均衡、熔断器等功能。

- RPC 框架的核心原理是基于网络传输协议实现的远程方法调用。RPC 框架通常由服务提供者和服务消费者两部分组成，服务提供者将本地方法暴露成远程服务，服务消费者通过远程代理对象调用远程方法。
- 在实现远程方法调用时，需要进行序列化和反序列化操作。序列化将对象转换为二进制数据流，以便于在网络中传输；反序列化则将接收到的二进制数据流转换为对象。
- 为了提高性能，一些 RPC 框架使用了二进制协议，如 Dubbo 使用的 Hessian2 协议和 gRPC 使用的 Protocol Buffers 协议，与基于文本的协议（如 XML 和 JSON）相比，二进制协议具有更小的传输体积和更高的解析速度，能够减少网络传输的开销。

#### 2.如何在 10 亿个数据中找到最大的 1 万个？（提示：最小堆）

java：使用最小堆来实现，可通过`PiortyQueue<Interger>`优先队列的方法，生成一个小顶堆。小顶堆是相当于值从小到大的在队列里面排序，头部元素就是最小值。 然后依次往里面插入数据，当pq.size()>10000时，我们就把堆顶元素给弹出，剩下的一万个数据就是最大值了。

```java
     PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
         // 小顶堆
         @Override
         public int compare(Integer o1, Integer o2) {
             return o1-o2;
         }
     });
```

#### 3.

### Day23

#### 1.有哪些主流的消息队里，他们分别有什么优缺点，各自的适用场景是什么

1. RabbitMQ 优点：可靠性高、性能优秀、支持多种协议、有完善的管理界面。 缺点：部署和维护较为复杂。 适用场景：适用于高可靠性、高吞吐量、多协议、多语言的分布式系统场景。
2. Kafka 优点：性能优秀、可扩展性好、可靠性高、支持多种数据处理模式。 缺点：管理界面不够完善、复杂度较高。 适用场景：适用于高吞吐量、高并发、数据处理流程复杂的场景，例如大数据处理、实时日志处理等。
3. ActiveMQ 优点：功能齐全、易于使用、支持多种协议。 缺点：性能相对较低、可靠性不如 RabbitMQ。 适用场景：适用于需要使用多种协议、支持多种消息类型的场景，例如 Web 服务、企业应用集成等。
4. RocketMQ 优点：性能优秀、可靠性高、支持海量数据存储和传输。 缺点：社区相对较小、功能不够完善。 适用场景：适用于海量数据存储和传输场景，例如电商、金融等领域。
5. Redis 优点：速度极快、支持多种数据结构、支持事务操作、支持发布/订阅模式。 缺点：可靠性不如 RabbitMQ 和 Kafka。 适用场景：适用于对性能要求极高、需要使用多种数据结构和事务操作的场景，例如缓存、计数器、实时消息等。

#### 2.Redis 有哪些数据类型？基础数据结构有几种？你还知道哪些 Redis 的高级数据结构？

1. String（字符串）：Redis 中最基本的数据类型，可以存储任何形式的数据，例如整数、浮点数、二进制数据等。
2. Hash（哈希）：Redis 中的一种键值对类型，可以存储多个键值对，每个键值对又是一个键值对结构。
3. List（列表）：Redis 中的一个有序列表类型，可以存储多个元素，每个元素都有一个索引，支持多种列表操作，例如插入、删除、查找等。
4. Set（集合）：Redis 中的一种无序集合类型，可以存储多个元素，每个元素都是唯一的，支持多种集合操作，例如交集、并集、差集等。
5. Sorted Set（有序集合）：Redis 中的一种有序集合类型，可以存储多个元素，每个元素都有一个分值，支持根据分值进行排序和查询等操作。

Redis 的基础数据结构有三种：字符串、列表和哈希，其他的数据类型都是基于这三种数据结构进行扩展和衍生的。例如，Redis 的 Set 数据类型就是基于字符串实现的。

除了基础数据结构之外，Redis 还提供了多种高级数据结构，例如：

1. HyperLogLog：一种基数估计算法，用于估计一个数据集合的基数。
2. GeoHash：一种地理位置编码算法，可以对地理位置信息进行编码和查询。
3. Pub/Sub：一种消息队列机制，可以实现消息的订阅和发布。
4. Bitmaps：一种位图数据结构，可以进行高效的位运算，用于统计用户在线时长、网站访问量等。
5. Lua 脚本：Redis 中可以使用 Lua 脚本进行扩展和定制，可以实现一些复杂的业务逻辑和算法。

### Day24

#### 1.Spring 支持哪几种事务管理类型，Spring 的事务实现方式和实现原理是？

- Spring支持的事务管理有

- 1. 编程式事务管理：使用编程的方式来管理事务，包括事务的开始、提交或回滚等操作，可以精细地控制事务的边界。
  2. 声明式事务管理：使用注解或 XML 配置来声明事务的属性，例如事务的隔离级别、传播行为、超时时间等，Spring 会自动为这些方法添加事务管理的支持，无需手动编写事务管理代码。
  3. 注解式事务管理：通过在方法上添加 `@Transactional` 注解，开发人员可以非常方便地声明事务的属性，例如隔离级别、传播行为、超时时间等

- Spring 的事务实现方式和实现原理是

  Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。

  Spring 的事务实现方式采用了模板模式，通过模板模式实现了事务的封装。Spring 事务管理实现原理主要是通过 AOP 和代理模式来实现的。在使用声明式事务管理时，Spring 通过拦截器和代理对象来实现对方法调用的拦截和控制。当方法被调用时，Spring 会在方法调用前开启一个新的事务，如果方法执行成功，Spring 会提交事务，否则回滚事务。在使用注解式事务管理时，Spring 会扫描带有事务注解的方法，并在运行时使用动态代理为这些方法生成代理对象，在代理对象的方法调用前后进行事务管理的操作。

1. **事务管理器（Transaction Manager）**：Spring 事务管理器是事务的核心组件，它负责管理事务的生命周期和事务的状态。Spring 事务管理器提供了多种实现，包括 JDBC、Hibernate、JPA、JTA 等，开发人员可以根据自己的需求来选择适合的事务管理器。
2. **事务代理（Transaction Proxy）**：Spring 使用代理模式来实现事务管理，即通过代理对象来拦截被代理对象的方法调用，以实现事务的开启、提交或回滚等操作。Spring 事务代理有两种实现方式：基于 AOP 的代理和基于动态代理的代理。
3. **事务切面**（Transaction Aspect）：Spring 事务切面是一组通知（Advice）和切点（Pointcut）的组合，用于定义事务的行为，例如事务的开启、提交或回滚等操作。Spring 事务切面可以基于注解或 XML 配置来实现，开发人员可以根据自己的需求来选择适合的方式。
4. **事务同步器**（Transaction Synchronization）：Spring 事务同步器用于管理事务的提交或回滚时需要执行的一些操作，例如清理缓存、释放资源等。Spring 事务同步器通过 Synchronization 接口和 TransactionSynchronizationManager 类来实现，可以实现对事务的后置处理。

#### 2.Redis 为什么快

Redis 之所以快，主要有以下几个方面的原因：

1. 内存存储：Redis 的数据都是存储在内存中的，相比于硬盘存储的数据库，内存存储速度更快。
2. 单线程模型：Redis 使用单线程模型处理所有的请求，避免了多线程之间的线程切换和竞争等开销，提高了处理请求的效率。
3. 非阻塞 I/O：Redis 使用非阻塞 I/O 处理网络通信，当一个客户端请求到来时，Redis 不会一直等待客户端的响应，而是会先处理其它的请求，这样就避免了 I/O 阻塞带来的性能问题。
4. 精简高效的数据结构：Redis 内置了多种高效的数据结构，如哈希表、跳表等，这些数据结构的实现非常精简高效，减少了 Redis 对内存和 CPU 的占用，从而提高了 Redis 的性能。
5. 持久化策略：Redis 支持多种持久化策略，如 RDB（快照）和 AOF（追加式文件）等，这些策略可以将内存中的数据保存到硬盘中，以保证数据的持久性和安全性。同时，Redis 可以将数据以压缩的方式存储在硬盘中，减少了硬盘的占用，提高了数据的读写速度。

综上所述，Redis 之所以快，主要得益于其内存存储、单线程模型、非阻塞 I/O、高效的数据结构和灵活的持久化策略等方面的设计和实现。

#### 3.简述 TCP 三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手？

TCP 三次握手和四次挥手是 TCP 协议中建立和终止连接的过程。



三次握手的流程如下：

1. 客户端向服务器发送 SYN 包，表示请求建立连接，此时客户端进入 SYN_SENT 状态。
2. 服务器接收到 SYN 包后，回应一个 SYN-ACK 包，表示同意建立连接，此时服务器进入 SYN-RECEIVED 状态。
3. 客户端接收到 SYN-ACK 包后，向服务器回应一个 ACK 包，表示确认建立连接，此时客户端进入 ESTABLISHED 状态。服务器收到 ACK 包后也进入 ESTABLISHED 状态。



四次挥手的流程如下：

1. 客户端向服务器发送 FIN 包，表示希望关闭连接，此时客户端进入 FIN-WAIT-1 状态。
2. 服务器接收到 FIN 包后，向客户端回应一个 ACK 包，表示已经收到了关闭请求，此时服务器进入 CLOSE-WAIT 状态，客户端收到 ACK 包后进入 FIN-WAIT-2 状态。
3. 服务器关闭连接后，向客户端发送一个 FIN 包，表示可以关闭连接，此时服务器进入 LAST-ACK 状态。
4. 客户端接收到服务器的 FIN 包后，向服务器回应一个 ACK 包，表示已经收到关闭请求，此时客户端进入 TIME-WAIT 状态，等待 2MSL（最大报文生存时间）后，关闭连接。服务器收到 ACK 包后也进入 CLOSED 状态。

三次握手是为了确保客户端和服务器都能够收到对方的请求和回应，防止因为网络原因导致请求或回应丢失而建立不了连接。四次挥手则是为了确保连接的正常关闭，防止因为网络原因导致连接无法关闭或者出现连接断开后还能够接收到数据的情况。

### Day25

#### 1.什么是工厂模式？使用工厂模式有什么好处？工厂模式有哪些分类？各自的应用场景是什么？

工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种封装对象创建过程的方法。工厂模式将对象的创建和使用分离，让一个专门的工厂类负责创建对象实例，而不是在代码中直接使用`new`操作符。这有助于降低代码的耦合度，提高可维护性和可扩展性。

使用工厂模式的好处：

1. 降低耦合度：工厂模式将对象的创建与使用分离，使得客户端代码不直接依赖具体的类，降低了耦合度。
2. 提高可扩展性：当需要添加或修改产品类时，只需修改工厂类，而不需要修改客户端代码，提高了系统的可扩展性。
3. 提高可维护性：通过集中管理对象的创建，提高了代码的可维护性。
4. 提高代码复用性：工厂类可以被多个客户端代码复用，减少了重复代码。

工厂模式可以分为以下几类：

1. 简单工厂模式（Simple Factory Pattern）：一个工厂类根据传入的参数决定创建哪个具体产品类的实例。简单工厂模式适用于产品种类较少且不易变化的场景。 应用场景：例如，一个简单的图形绘制工具，可以根据传入的参数创建不同类型的图形（如圆形、矩形等）。
2. 工厂方法模式（Factory Method Pattern）：定义一个接口或抽象类来创建对象，将实际创建对象的工作推迟到子类中。工厂方法模式适用于产品种类较多且可能增加的场景。 应用场景：例如，一个日志记录器，可以根据不同的需求（如文件日志、数据库日志等）使用不同的工厂子类创建相应的日志记录器实例。
3. 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。抽象工厂模式适用于产品族的场景。 应用场景：例如，跨平台UI框架，可以为不同平台（如Windows、macOS等）提供不同的UI控件实现，通过抽象工厂来创建对应平台的一系列UI控件。

各种工厂模式的应用场景取决于实际需求，需要根据具体问题来选择合适的工厂模式。

#### 2.什么是注册中心？如何实现一个注册中心？

注册中心（Service Registry）是微服务架构中的一个关键组件，负责管理服务实例的信息，包括服务实例的地址、端口、元数据等。它允许服务实例在启动时注册自己，并在关闭时注销。服务消费者可以通过查询注册中心来发现可用的服务提供者，并根据负载均衡策略选择合适的服务实例进行调用。



实现一个注册中心需要以下几个关键功能：

1. 服务注册：允许服务实例在启动时将自己的信息注册到注册中心，包括地址、端口、元数据等。
2. 服务注销：允许服务实例在关闭时从注册中心注销自己。
3. 服务发现：允许服务消费者查询可用的服务实例列表，以便找到合适的服务实例进行调用。
4. 健康检查：注册中心需要定期检查已注册的服务实例的健康状况，以确保服务实例列表的准确性。如果发现某个服务实例不再可用，注册中心应将其从列表中移除。



实现一个简单的注册中心可以参考以下步骤：

1. 选择一个合适的数据结构（例如哈希表）存储服务实例的信息。
2. 实现一个HTTP API，允许服务实例在启动时向注册中心发送注册请求，将自己的信息添加到数据结构中。
3. 实现一个HTTP API，允许服务实例在关闭时向注册中心发送注销请求，将自己的信息从数据结构中移除。
4. 实现一个HTTP API，允许服务消费者查询可用的服务实例列表。
5. 实现一个定时任务，定期检查已注册的服务实例的健康状况，如果发现某个服务实例不再可用，将其从数据结构中移除。



然而，实现一个可靠、高性能、可扩展的注册中心是一个复杂的任务。在实际应用中，通常推荐使用现有的成熟的注册中心组件，例如Eureka、Consul、Zookeeper等。这些注册中心提供了丰富的功能，包括高可用性、数据持久化、动态配置等。

#### 3.什么是 Spring 的依赖注入，依赖注入的基本原则以及好处？

Spring 的依赖注入（Dependency Injection，简称 DI）是指，在一个对象创建时，由 Spring 框架动态地将其依赖的其他对象注入到它当中，以解耦对象之间的关系，达到灵活、可维护、可测试的目的。

依赖注入的基本原则是控制反转（Inversion of Control，简称 IoC），即将对象之间的关系由调用者的控制转变为被调用者的控制。在传统的开发模式中，一个对象创建时通常需要主动创建它所依赖的其他对象，这些对象的创建、配置、连接等关系都由这个对象主动控制，这会导致对象之间高耦合、难以扩展、难以维护。而采用依赖注入的方式，则将这些依赖关系交给 Spring 框架来处理，大大降低了对象之间的耦合度，提高了代码的可读性、可维护性和可扩展性。



依赖注入的好处主要有以下几点：

1. 灵活性：通过依赖注入，对象之间的关系不再由程序员手动控制，而是由 Spring 容器动态地维护，可以灵活地组合和切换不同的对象实现。
2. 可测试性：依赖注入可以使各个对象之间的依赖关系更加松散，方便进行单元测试和集成测试。
3. 可扩展性：依赖注入将各个对象之间的依赖关系解耦，方便对系统进行扩展和升级。
4. 可维护性：依赖注入可以减少重复代码，降低了代码的复杂度，使代码更加易于维护和修改。

### Day26

#### 1.如何使用 Redis 实现分布式锁？

redis实现分布式锁：使用Redis实现分布式锁的基本思路是使用Redis的原子性操作来确保在多个客户端之间只有一个客户端可以成功获取锁。

- redis实现分布式锁的方式有两种：

  1. 通过redis提供的setnx进行实现，往redis中使用setnx插入key时，如果key存在，则返回0，可以通过插入key的返回值进行判断来实现分布式锁
  2. 通过使用Redission（客户端）来实现分布式锁。可以调用Redission提供的api，即lock()，unlock()方法进行加锁和锁的释放。此外，Redission还提供了watchdog，即看门狗，来对加锁的key每隔10s对该key进行续时，（从而避免锁的过期）
     - Redission的所有指令是通过lua脚本进行实现的，lua脚本可以保证所有指令执行的原子性

- 步骤

  1. 获取锁：客户端尝试获取锁，可以使用Redis的`SET`命令结合`NX`和`EX`选项来实现。`SET`命令用于设置一个键值对，`NX`选项表示只有在键不存在时才设置，`EX`选项表示设置一个过期时间（单位为秒）。 示例：`SET lock_key unique_value NX EX 30`。这个命令表示如果`lock_key`不存在，就设置它的值为`unique_value`，并设置30秒的过期时间。如果设置成功，表示获取锁成功；如果设置失败，表示锁已被其他客户端持有，需要等待或重试。

  2. 持有锁：在持有锁的客户端执行临界区代码。在此期间，其他客户端无法获取锁。

  3. 释放锁：在临界区代码执行完毕后，需要释放锁以供其他客户端使用。为了避免误解锁的情况（例如，由于执行时间过长导致锁过期，然后被其他客户端获取），在释放锁时需要检查锁的值是否与获取锁时设置的值相同。这可以通过Redis的`EVAL`命令来实现，使用Lua脚本进行原子性操作。 示例：

     ```lua
     EVAL "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end" 1 lock_key unique_value。
     ```

     这个命令表示检查`lock_key`的值是否为`unique_value`，如果是，则删除`lock_key`以释放锁；否则不执行任何操作。

- [参考](https://www.code-nav.cn/post/1636382314944581634)

#### 2.什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？

BASE理论是分布式系统中用于描述数据一致性的一个概念。它是一个缩写，分别代表：

1. 基本可用（Basic Availability）：分布式系统在出现故障时，依然能够保证系统的可用性，但可能会出现部分功能或性能降低的情况。
2. 软状态（Soft State）：由于分布式系统中各个节点的状态可能会有一定的延迟，系统允许在一定时间内存在数据不一致的情况。
3. 最终一致性（Eventual Consistency）：在一段时间内，分布式系统中的数据可能不一致，但最终会达到一致状态。这个过程可能需要一定的时间。

CAP理论是另一个关于分布式系统的理论，它指出在分布式系统中，不能同时满足以下三个属性：

1. 一致性（Consistency）：在分布式系统中的所有节点，在同一时刻具有相同的数据。
2. 可用性（Availability）：分布式系统在任何时刻都能对外提供服务，响应用户请求。
3. 分区容错性（Partition Tolerance）：分布式系统在遇到网络分区（部分节点之间通信中断）的情况下仍然能够正常运行。

BASE理论和CAP理论之间的关系是：BASE理论实际上是对CAP理论的一种实践和解释。在CAP理论中，由于无法同时满足三个属性，因此在实际的分布式系统设计中，通常需要在一致性和可用性之间做出权衡。BASE理论就是这种权衡的一种体现，它强调基本的可用性、软状态和最终一致性，而不是追求强一致性。在很多场景中，采用BASE理论能够带来更高的系统可用性和更好的性能表现。

#### 3.什么是 AOP？有哪些实现 AOP 的方式？Spring AOP 和 AspectJ AOP 有什么区别？

AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它旨在解决软件开发中的横切关注点（cross-cutting concerns）问题。横切关注点是那些分布于多个模块或对象的功能，例如日志记录、安全检查、事务管理等。AOP通过将横切关注点与业务逻辑分离，从而提高了代码的模块化程度，使得开发更加简洁、易于维护。



Spring AOP和AspectJ AOP是两种不同的AOP实现。

1. Spring AOP：是Spring框架中的AOP实现，基于动态代理实现。Spring AOP主要用于解决Spring容器中Bean的横切关注点问题。由于它使用了动态代理，所以只支持方法级别的切面（即横切关注点只能织入方法的执行）。Spring AOP的性能略逊于AspectJ，但对于大部分应用来说，性能影响不大。
2. AspectJ AOP：是一个独立的、功能更强大的AOP实现，不仅支持方法级别的切面，还支持字段、构造器等其他切面。AspectJ可以通过编译时织入（编译时修改字节码）或加载时织入（在类加载时修改字节码）的方式实现AOP。Spring可以与AspectJ结合使用，以提供更强大的AOP功能。



实现AOP的方式主要有以下几种：

1. 动态代理：通过代理模式，为目标对象生成一个代理对象，然后在代理对象中实现横切关注点的织入。动态代理可以分为JDK动态代理（基于接口）和CGLIB动态代理（基于类）。
2. 编译时织入：在编译阶段，通过修改字节码实现AOP。AspectJ的编译时织入就是这种方式。
3. 类加载时织入：在类加载阶段，通过修改字节码实现AOP。AspectJ的加载时织入就是这种方式。



AOP的实现方式取决于具体需求和技术选型。对于Spring应用来说，通常可以使用Spring AOP满足大部分需求，如果需要更强大的AOP功能，可以考虑使用AspectJ。

### Day27

#### 1.有几台机器存储着几亿的淘宝搜索日志，假设你只有一台 2g 的电脑，如何选出搜索热度最高的十个关键词？

对于 **top k 类文本问题**，通常比较好的方案是【**分治+hash/trie 树+小顶堆**】，即先按照 hash 方法把数据集分解成多个**小数据集**，然后使用 **trie 树**或者 **hash** 统计每个**小数据集**中的**词频**，随后用**小顶堆**求出**每个数据集中出现频率最高的前 K 个数**，最后在**所有 top K 中求出最终的 top K**。

**拆分成 n 多个文件**：以**首字母区分**，不同首字母放在不同文件，如果某个文件长度仍过长，继续按照次首字母进行拆分。这样一来，每个文件的每个数据长度基本相同且首字母相同，就能保证数据被独立的分为了 n 个文件，且各个文件中不存在关键词的交集。

**分别词频统计**：对于每个文件，使用 **hash** 或者 **Trie** 树进行进行**词频统计**

**小顶堆排序**：依次处理每个文件，并逐渐更新最大的十个词

#### 2.有哪些常见的消息队列模型？分别适用于什么场景？

**消息队列**是一种在分布式系统中用于**异步通信**的模型，它允许不同的组件通过将消息发送到队列来实现解耦和灵活性。以下是常见的消息队列模型及其适用场景：

1. **点对点模型**（Point-to-Point Model）：这种模型中，**消息生产者**将消息发送到一个**队列**中，**消息消费者**从该队列中接收消息。**一个消息只会被一个消费者接收**，消费者在处理完消息之后会从队列中删除它。这种模型适用于**需要保证消息只被一个消费者处理的场景**，例如**订单系统、日志处理**等。
2. **发布-订阅模型**（Publish-Subscribe Model）：这种模型中，**消息生产者**将消息发送到一个**主题（Topic）**中，多个**消息消费者**可以**订阅**该主题并接收到所有的消息。**每个消息可以被多个消费者接收**，消费者在处理完消息之后不会从主题中删除它。这种模型适用于**需要将消息广播给多个消费者的场景**，例如**新闻订阅**、**实时数据分析**等。
3. **请求-应答模型**（Request-Response Model）：这种模型中，**消息生产者**发送一个请求消息到一个队列中，**消息消费者**从该队列中接收请求并返回一个响应消息。**一个请求只会被一个消费者接收并处理**，处理完成后返回**响应消息**给消息生产者。这种模型适用于需要**请求-响应**模式的场景，例如**远程过程调用、微服务通信**等。
4. **推拉模型**（Push-Pull Model）：这种模型中，**消息生产者**将消息**推送**到一个**队列**中，**消息消费者**从该队列中**拉取消息**。消息生产者将消息发送到队列中，消费者**按需**从队列中拉取消息进行处理。这种模型适用于**需要灵活控制消息消费速度**的场景，例如**数据采集、视频流传输**等。

需要注意的是，以上模型并不是完全独立的，实际使用中可以根据具体场景**组合使用**不同的模型。例如，可以将**点对点模型和请求-应答模型**结合使用，实现**异步的 RPC 调用**。另外，在选择消息队列模型时，还需要考虑消息传输的**可靠性、顺序性、延迟**等因素。

#### 3.如何用 Redis 中的 HyperLogLog 统计页面 UV?

```java
import redis.clients.jedis.Jedis;

public class PageUVCounter {

    private Jedis jedis;

    public PageUVCounter(Jedis jedis) {
        this.jedis = jedis;
    }

    public void countUV(String pageName, String userId) {
        String hllKey = "uv:" + pageName;
        jedis.pfadd(hllKey, userId);
    }

    public long getUV(String pageName) {
        String hllKey = "uv:" + pageName;
        return jedis.pfcount(hllKey);
    }

}
```

使用Jedis客户端实现了`PageUVCounter`类。`countUV`方法用于统计页面UV，它使用Redis的`pfadd`命令将用户ID添加到HyperLogLog中。`getUV`方法用于获取页面UV，它使用Redis的`pfcount`命令获取HyperLogLog中的基数计数值，即页面的UV数量。

**注意的点**：

- HyperLogLog是有误差的，误差范围在0.81%以内，因此在实际使用中需要根据误差范围进行适当的调整。
- HyperLogLog中存储的是用户ID的哈希值，因此需要确保用户ID的哈希分布均匀，以避免误差过大。

### Day28

#### 1.简述 TCP/IP 网络模型，分为几层？每层的职责和作用是什么？

1. 应用层：应用层为用户提供网络服务，应用层的任务是通过应用程序完成特定的网络功能。应用层负责处理与应用程序的通信和数据传输，它包括多种应用层协议，如 HTTP、FTP、DNS 等。这些协议定义了客户端和服务器之间如何互相发送和接收数据的交互规范。例如向服务器发送 HTTP 请求，或从 DNS 服务器获取 IP 地址等。为应用程序提供用户接口、数据传输以及数据封装和解析封装。
2. 传输层：传输层主要负责提供端到端的数据传输服务，包括 TCP 和 UDP 协议。TCP 提供面向连接、可靠的数据传输服务，而 UDP 则提供无连接、不可靠的数据传输服务。传输层的主要任务是保证数据的可靠性，实现数据的分段和重组，并且确保数据按照正确的顺序到达目的地。
3. 网络层：网络层负责在不同网络之间进行数据包的路由和传输。它使用 IP（互联网协议）进行寻址和路由，将数据包从源主机传输到目的主机。其中包括IP地址的分配、路由选择、分组传输和拥塞控制等功能。
4. 数据链路层：数据链路层主要负责在物理层上传输数据。它将网络层传输的数据进行分帧，并添加了物理地址（MAC 地址）以及校验和等信息，使其可以在物理层上传输。

它们之间的具体过程是这样：

发送方：

- 应用层：应用层向下传输报文，报文中包含应用层自己的报头和应用层的数据。
- 传输层：传输层接收到应用层的报文，将应用层报文封装成一个或多个数据段，同时添加传输层的报头信息，例如TCP的源端口和目标端口号等。
- 网络层：网络层接收到传输层的数据段，将数据段打包成IP数据包，同时添加网络层的报头信息，例如源IP地址和目标IP地址等。
- 数据链路层：数据链路层接收到IP数据包，将其封装成数据帧，同时添加数据链路层的报头信息，例如源MAC地址和目标MAC地址等。
- 物理层：物理层接收到数据帧，将其转换为0和1的电信号，通过物理介质传输到接收方，接收方的物理层将电信号转换为数据帧。

接收方：接收方也会按照相反的顺序层层解析报文。

- 物理层：物理层传来的0和1的电信号，并将其转换为数据帧。
- 数据链路层：会解析数据帧中的报头信息，剥离数据链路层的报头信息，并将剩余的数据包交给网络层。
- 网络层：解析数据包中的报头信息，剥离网络层的报头信息，并将剩余的数据段交给传输层。
- 传输层：解析数据段中的报头信息，剥离传输层的报头信息，并将剩余的数据段重组成完整的数据，并交给应用层。
- 应用层：解析数据中的应用层报文，并进行处理和响应。

整个接收过程与发送过程类似，但是在每一层都需要进行不同的处理，以确保数据能够被正确地接收、还原和处理。

#### 2.什么是正向代理和反向代理，如何使用 Nginx 做反向代理？

**正向代理**和**反向代理**都是代理服务器的两种应用场景，它们在网络请求的处理过程中扮演不同的角色：

**正向代理**（Forward Proxy）：正向代理**位于客户端和目标服务器之间**，客户端通过正向代理来访问目标服务器。正向代理代表客户端发起请求，**隐藏客户端的真实身份**。常见的应用场景包括**使用魔法、访问内网资源、缓存和过滤**等。

**反向代理**（Reverse Proxy）：**反向代理位于客户端和目标服务器之间**，客户端直接访问反向代理服务器，反向代理将请求转发给目标服务器。反向代理代表目标服务器接收请求，隐藏目标服务器的真实身份。常见的应用场景包括**负载均衡、安全防护、缓存和SSL终端**等。

使用Nginx作为反向代理的方法如下：

安装Nginx：根据操作系统和需求选择合适的Nginx版本进行安装。安装完成后，启动Nginx。

配置反向代理：编辑Nginx的配置文件（通常位于/etc/nginx/nginx.conf或/etc/nginx/sites-available/default），在http或server块中添加反向代理配置。

示例配置：

```config
http {
    ...
    server {
        listen 80; # 监听的端口号
        server_name example.com; # 反向代理的域名

        location / {
            proxy_pass http://backend_server; # 将请求转发给目标服务器
            proxy_set_header Host $host; # 设置请求头部信息
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
    
}
```

在这个示例中，将客户端的请求转发给名为backend_server的目标服务器。同时设置了一些请求头部信息，以便目标服务器获取客户端的真实IP地址。

重启Nginx：保存配置文件并重启Nginx，使配置生效。通常可以使用nginx -s reload或systemctl restart nginx命令重启Nginx。

完成以上步骤后，Nginx就被配置为反向代理服务器，可以将客户端的请求转发给目标服务器。

#### 3.什么是双亲委派模式？有什么作用？

**双亲委派**模式（Parent-Delegate Model）是 **Java 类加载器**（ClassLoader）在**加载类**时所采用的一种**设计模式**。这种模式的核心思想是：当一个**类加载器**收到**类加载请求**时，首先不会尝试自己加载这个类，而是将**请求委派给其父类加载器**。依次递归，直到**最顶层的启动类加载器**（Bootstrap ClassLoader）；**如果父类加载器无法加载该类，子类加载器才尝试自己去加载。**

**双亲委派模式**的作用主要有以下几点：

1. **避免类的重复加载**：通过委派给父类加载器加载类，可以确保同一个类不会被多个类加载器重复加载。这有助于节省内存资源，并确保类之间的互操作性。
2. **保护 Java 核心类库**：由于双亲委派模式的存在，**用户自定义的类加载器无法直接加载 Java 核心类库**（如java.lang.Object等）。这有助于确保 Java 核心类库的安全性，防止恶意代码篡改或破坏Java核心类。
3. **维护类加载器的层次结构**：双亲委派模式使得各级类加载器可以按照一定的层次结构来组织和管理。这有助于降低类加载器的复杂性，简化类加载过程。

双亲委派模式在 Java 类加载器中的应用是一种优秀的设计原则，它有助于确保类加载过程的稳定性、安全性和可维护性。

然而，在某些特殊场景下（如 OSGi、Java 热加载等），双亲委派模式可能无法满足需求，需要采用其他类加载策略。在这些场景下，开发者需要充分了解类加载机制，以避免产生意外的问题。

### Day29

#### 1.你是否了解过新版本的 Java 特性？对 Java 未来的发展有什么看法？

- java 8

  1. 接口的默认方法

     为了解决接口的修改与现有的实现不兼容的问题。Java8的 interface 的方法可以用`default` 或 `static`修饰，这样就可以有方法体，实现类也不必重写此方法。

  2. functional interface [函数式接口](https://so.csdn.net/so/search?q=函数式接口&spm=1001.2101.3001.7020)

     **函数式接口是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口**。这样的接口，可以被隐式转换为lambda表达式。

  3. Lambda 表达式

     使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的函数式编程。

  4. Stream

     Stream依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。

  5. Optional

     1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。
     2） 数据库的查询结果可能为 null。
     3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。
     4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。
     5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。
     6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。

  6. Date-Time API：提供了一组强大的时间操作类，简化了日期和时间的操作。

- java 9

  1. JShell

     JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。

     在 JShell 中可以直接输入表达式并查看其执行结果。一旦语句输入完成，JShell 立即就能返回执行的结果，而不再需要编辑器、编译器、解释器。

  2. 模块化系统

     模块系统是Jigsaw Project的一部分，把模块化开发实践引入到了 Java 平台中，可以让我们的代码可重用性更好！

  3. G1 成为默认[垃圾回收器](https://so.csdn.net/so/search?q=垃圾回收器&spm=1001.2101.3001.7020)

     在 Java 8 的时候，默认垃圾回收器是 Parallel Scavenge（新生代）+Parallel Old（老年代）。到了 Java 9, G1（Garbage-First Garbage Collector） 成为了默认垃圾回收器。

  4. 快速创建不可变集合

     增加了List.of()、Set.of()、Map.of() 和 Map.ofEntries()等工厂方法来创建不可变集合（有点参考 Guava 的味道）。

  5. String 存储结构优化

     Java 8 及之前的版本，String 一直是用 char[] 存储。在 Java 9 之后，String 的实现改用 byte[] 数组存储字符串，节省了空间。

  6. 接口私有方法

     Java 9 允许在接口中使用私有方法。这样的话，接口的使用就更加灵活了，有点像是一个简化版的抽象类。

  7. 进程 API

     Java 9 增加了 java.lang.ProcessHandle 接口来实现对原生进程进行管理，尤其适合于管理长时间运行的进程。

- java 10

  1. 局部变量类型推断(var)

     Java 10 采用了一个叫做 var 的保留类型来实现局部变量推断。要特别注意的是，为了兼容旧版本，var 不是关键字，而是一个保留类型，也就意味着你仍然可以像这样用 var 为你的变量和函数命名。

  2. G1 并行 Full GC优化
     为了最大限度地减少 Full GC 造成的应用停顿的影响，从 Java10 开始，G1 的 FullGC 改为并行算法。同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。

  3. 实验性的基于 Java 的 JIT 编译器

     Graal 是一个基于 Java 语言编写的 JIT 编译器，是 JDK 9 中引入的实验性 Ahead-of-Time (AOT) 编译器的基础。

- java 11

  1. HTTP Client 标准化

     Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。

  2. ZGC(可伸缩低延迟垃圾收集器)实验性使用

     ZGC 即 Z Garbage Collector，是一个可伸缩的、低延迟的垃圾收集器。

- java 12

  1. Shenandoah GC实验性使用
     Redhat 主导开发的 Pauseless GC 实现，主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等

     和 Java11 开源的 ZGC 相比（需要升级到 JDK11 才能使用），Shenandoah GC 有稳定的 JDK8u 版本，在 Java8 占据主要市场份额的今天有更大的可落地性。

  2. G1 收集器优化

     Java12 为默认的垃圾收集器 G1 带来了两项更新:

     - 可中止的混合收集集合
     - 及时返回未使用的已分配内存

- java 13

  1. 增强 ZGC(释放未使用内存)
     在 Java 11 中是实验性的引入的 ZGC 在实际的使用中存在未能主动将未使用的内存释放给操作系统的问题。

     ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 ZPageCache 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织。

  2. SocketAPI 重构

     Java 13 将 Socket API 的底层进行了重写， NioSocketImpl 是对 PlainSocketImpl 的直接替代，它使用 `java.util.concurrent` 包下的锁而不是同步方法。

- Java 14

  - record 关键字
    record 关键字可以简化 数据类（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 record 代替 class 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 toString()，hashCode(), equals()方法。

- Java 15

  1. ZGC(转正)
     Java11 的时候 ，ZGC 还在试验阶段。

     当时，ZGC 的出现让众多 Java 开发者看到了垃圾回收器的另外一种可能，因此备受关注。

     经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！

     不过，默认的垃圾回收器依然是 G1.

  2. 密封类（Sealed Classes）
     Java 15 对 Java 14 中引入的预览新特性进行了增强，主要是引入了一个新的概念 密封类（Sealed Classes）。

     密封类可以对继承或者实现它们的类进行限制。

     比如抽象类 Person 只允许 Employee 和 Manager 继承。

- Java 16

  - revord 记录类型（转正）

    revord 记录类型正式转正。

- [参考](https://blog.csdn.net/soul_sky/article/details/126000904)

#### 2.CC 攻击是什么？什么叫 DDOS 攻击？什么是网站数据库注入？

- CC 攻击

  - CC 攻击（CC Attack）是一种网络攻击方式，全称为“压力测试（Concurrent Connections）攻击”。它通常是指对服务器进行大量并发请求的攻击，从而导致服务器的瘫痪。攻击者通过使用大量的机器或网络中的代理服务器，向目标服务器发送大量的请求，以消耗服务器的带宽和资源，从而使其无法正常提供服务。CC 攻击可以是攻击者自己编写的脚本，也可以是专门的 CC 攻击工具。

  - CC攻击现象：

    1. 网站服务器的流量瞬间可达到几十M以上，网站打不开；

    2. 查看日志，发现不同的IP都反复访问一个相同的文件。

- DDOS攻击

  - 分布式拒绝服务（Distributed Denial of Service，简称DDoS）将多台计算机联合起来作为攻击平台，通过远程连接，利用恶意程序对一个或多个目标发起DDoS攻击，消耗目标服务器性能或网络带宽，从而造成服务器无法正常地提供服务。

  - 攻击原理

    通常，攻击者使用一个非法账号将DDoS主控程序安装在一台计算机上，并在网络上的多台计算机上安装代理程序。在所设定的时间内，主控程序与大量代理程序进行通讯，代理程序收到指令时对目标发动攻击，主控程序甚至能在几秒钟内激活成百上千次代理程序的运行。
  - DDoS攻击的危害

    DDoS攻击会对您的业务造成以下危害：

    - 重大经济损失

      在遭受DDoS攻击后，您的源站服务器可能无法提供服务，导致用户无法访问您的业务，从而造成巨大的经济损失和品牌损失。

      例如：某电商平台在遭受DDoS攻击时，网站无法正常访问甚至出现短暂的关闭，导致合法用户无法下单购买商品等。

    - 数据泄露

      黑客在对您的服务器进行DDoS攻击时，可能会趁机窃取您业务的核心数据。

    - 恶意竞争

      部分行业存在恶性竞争，竞争对手可能会通过DDoS攻击恶意攻击您的服务，从而在行业竞争中获取优势。

      例如：某游戏业务遭受了DDoS攻击，游戏玩家数量锐减，导致该游戏业务几天内迅速彻底下线。
    
  - DDoS攻击现象：

    1.被攻击主机上有大量等待的TCP连接;

    2.网络中充斥着大量无用数据包;

    3.源地址为假，制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯;

    4.利用受害主机提供的传输协议上的缺陷，反复高速地发出特定的服务请求，使主机无法处理所有正常请求;

    5.严重时会造成系统死机。

- 网站数据库注入

  - 网站数据库注入（SQL Injection）是一种利用 Web 应用程序漏洞的攻击方式，攻击者通过将恶意 SQL 代码插入到 Web 应用程序的输入字段中，从而获取对数据库的未授权访问。网站数据库注入攻击可以导致许多问题，如破坏数据库的完整性、泄漏敏感数据、执行未经授权的操作等。常见的防御措施包括输入验证、参数化查询、使用安全的 API 等。

#### 3.常见的垃圾回收算法有几种类型？他们对应的优缺点是什么？

- 常见的垃圾回收算法有：

  标记-清除算法、复制算法、标记-整理算法、分代收集算法

- 标记-清除算法

  标记—清除算法包括两个阶段：“标记”和“清除”。 标记阶段：确定所有要回收的对象，并做标记。 清除阶段：将标记阶段确定不可用的对象清除。

- 缺点：

  标记和清除的效率都不高。
  会产生大量的碎片，而导致频繁的回收。

- 复制算法

  内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候， 把存活的对象复制到另一块上，然后把这块内存整个清理掉。

- 缺点：

  需要浪费额外的内存作为复制区。
  当存活率较高时，复制算法效率会下降。

- 标记-整理算法

  标记—整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存。

- 缺点：

  算法复杂度大，执行步骤较多

- 分代收集算法

  目前大部分 JVM 的垃圾收集器采用的算法。根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为新生代（ Young Generation 和老年代（ Tenured Generation ），永久代（ Permanet Generation ）。

  1. 老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。
  2. Young：存放新创建的对象，对象生命周期非常短，几乎用完可以立即回收，也叫 Eden 区。
  3. Tenured： young 区多次回收后存活下来的对象将被移到 tenured 区，也叫 old 区。
  4. Perm：永久代，主要存加载的类信息，生命周期长，几乎不会被回收。

- 缺点： 算法复杂度大，执行步骤较多。

# 十四.高频

### 1.IOC,DI,AOP

#### IOC

- 基本概念
  - IOC(Inverse Of Controll,控制反转)：就是原来代码里面需要自己手动创建的对象，依赖，反转给Spring来帮忙实现。我们需要创建一个容器，同时需要一种描述来让容器知道要创建的对象与对象之间的关系。
  - 在Spring中BeanFactory就是IOC容器，在Spring初始化的时候，创建容器，并将需要创建对象和对象的关系（xml，注解）通过BeanDefinitionReader加载到BeanDefinition中并保存在BeanDefinitionMap中，然后再由IOC容器创建bean对象.
- 两种bean的注册方式
  - 方法1：通过@Bean+@Configuration的方式直接定义要创建的对象与对象的关系
  - 方式2：通过@Component定义类，这种方式必须使用@ComponetScan定位Bean扫描路径

#### AOP

(从概念,实现,作用)

- AOP

  在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口采用 JDK 动态代理，如果是类采用CGLIB 方式实现动态代理。

- 相关概念

  - Joinpoint(连接点)：就是方法

  - Pointcut(切入点)：就是挖掉共性功能的方法

  - Advice(通知)：就是共性功能，最终以一个方法的形式呈现

  - Aspect(切面)：就是共性功能与挖的位置的对应关系

  - Target(目标对象)：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的

  - 提供的右下方Weaving(织入)：就是将挖掉的功能回填的动态过程

  - Proxy(代理)：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现

  - Introduction(引入/引介) ：就是对原始对象无中生有的添加成员变量或成员方法

- 实现

  1）获取增强器，例如被 Aspect 注解修饰的类。

  2）在创建每⼀个 bean 时，会检查是否有增强器能应⽤于这个 bean，简单理解就是该 bean 是否在该增强器指定的 execution 表达式中。如果是，则将增强器作为拦截器参数，使⽤动态代理创建bean 的代理对象实例。

  3）当我们调⽤被增强过的 bean 时，就会⾛到代理类中，从⽽可以触发增强器，本质跟拦截器类似。

#### DI

在使用Spring框架之后，对象的实例不再由调用者来创建，而是由Spring容器来创建，Spring容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，控制权由应用代码转移到了Spring容器，控制权发生了反转，这就是Spring的控制反转。

从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，这相当于为调用者注入了它依赖的实例，这就是Spring的依赖注入


### 2.如何用 Redis 实现分布式 Session？

在分布式系统中，通常会将 Session 存储在 Redis 中来实现分布式 Session，这样就可以在多台服务器之间共享 Session 数据。实现分布式 Session 的方式有多种，其中一种常用的方式是使用 Redis 的数据结构 Hash。具体实现步骤如下：

1. 在用户登录成功后，将 Session 数据存储在 Redis 中。
2. 将 Redis 中的 Session 数据的 Key 设置为一个全局唯一的 ID，一般使用类似于“session:token”这样的格式，其中 token 是一个随机生成的字符串，用来标识这个 Session 数据。
3. 在客户端返回响应的同时，将 Session ID（即 token）以 Cookie 的形式返回给客户端。客户端在后续的请求中都会携带这个 Cookie。
4. 在后续的请求中，服务器会从客户端传递过来的 Cookie 中获取 Session ID，然后根据这个 ID 从 Redis 中获取对应的 Session 数据。如果 Redis 中没有找到对应的 Session 数据，那么就表示这个请求无法通过认证。
5. 在用户退出登录或 Session 失效时，需要将 Redis 中的对应 Session 数据删除。

可以使用 Redis 的 EXPIRE 命令来设置 Session 数据的过期时间，这样可以自动删除已经过期的 Session 数据。同时，还需要注意保护 Redis 中的 Session 数据不被恶意攻击者窃取，一般可以通过设置 Session 数据的前缀和使用随机的 Session ID 等方式来提高安全性。

### 3.什么是双亲委派模式？有什么作用？

**双亲委派**模式（Parent-Delegate Model）是 **Java 类加载器**（ClassLoader）在**加载类**时所采用的一种**设计模式**。这种模式的核心思想是：当一个**类加载器**收到**类加载请求**时，首先不会尝试自己加载这个类，而是将**请求委派给其父类加载器**。依次递归，直到**最顶层的启动类加载器**（Bootstrap ClassLoader）；**如果父类加载器无法加载该类，子类加载器才尝试自己去加载。**

### 4.循环依赖

循环依赖

- A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。

- 举例

  ```java
  /**
  A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，
  此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程
  B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，
  B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象/
  ```

- 为什么需要三级缓存而不是二级缓存

  如果出现循环依赖+aop时，多个地方注入这个动态代理对象需要保证都是同一个对象，而三级缓存中的取出来的动态代理对象(通过ObjectFactory的getObejct()方法)每次都是新对象，地址值不一样。

  [参考](https://blog.csdn.net/ywl470812087/article/details/128494079)

### 5.什么是 BIO、NIO、AIO？

- BIO，全称 Blocking I/O，也称为同步阻塞 I/O。BIO 是最早的 I/O 模型，它是一种阻塞式的 I/O 模型，即当应用程序调用 I/O 操作时，该操作会一直阻塞线程直到操作完成，这会导致 I/O 性能低下。BIO 适用于连接数较小的场景，例如单线程的服务器模型。

  打算约女神，给女神发短信后，没见到女神就一直等在宿舍楼下。

- NIO，全称 Non-Blocking I/O，也称为同步非阻塞 I/O。NIO 是一种同步非阻塞的 I/O 模型，它的核心是 Selector 和 Channel，利用 Selector 监听多个 Channel 上的事件，当一个 Channel 上的事件到达时，它会被 Selector 转发给注册在这个 Selector 上的其他 Channel，这样可以用一个线程来处理多个请求，提高了 I/O 的效率。NIO 适用于连接数多、连接时间短的场景，例如实时聊天室、在线游戏等。

  打算约女神，给女神发短信后，没见到女神就一直发短信。

- AIO，全称 Asynchronous I/O，也称为异步非阻塞 I/O。AIO 是 JDK1.7 引入的 I/O 模型，它的特点是异步处理 I/O 操作，当操作完成时会通知应用程序，相比于 NIO 的同步非阻塞 I/O，AIO 无需通过轮询操作完成状态，从而提高了 I/O 的效率。AIO 适用于连接数多、连接时间长的场景，例如 HTTP 长连接、文件操作等。

  打算约女神，你发完短信，你就去玩游戏了，女神下楼了，发短信给你，你才出现。

### 6.有哪些主流的消息队里，他们分别有什么优缺点，各自的适用场景是什么

1. RabbitMQ 优点：可靠性高、性能优秀、支持多种协议、有完善的管理界面。 缺点：部署和维护较为复杂。 适用场景：适用于高可靠性、高吞吐量、多协议、多语言的分布式系统场景。
2. Kafka 优点：性能优秀、可扩展性好、可靠性高、支持多种数据处理模式。 缺点：管理界面不够完善、复杂度较高。 适用场景：适用于高吞吐量、高并发、数据处理流程复杂的场景，例如大数据处理、实时日志处理等。
3. ActiveMQ 优点：功能齐全、易于使用、支持多种协议。 缺点：性能相对较低、可靠性不如 RabbitMQ。 适用场景：适用于需要使用多种协议、支持多种消息类型的场景，例如 Web 服务、企业应用集成等。
4. RocketMQ 优点：性能优秀、可靠性高、支持海量数据存储和传输。 缺点：社区相对较小、功能不够完善。 适用场景：适用于海量数据存储和传输场景，例如电商、金融等领域。
5. Redis 优点：速度极快、支持多种数据结构、支持事务操作、支持发布/订阅模式。 缺点：可靠性不如 RabbitMQ 和 Kafka。 适用场景：适用于对性能要求极高、需要使用多种数据结构和事务操作的场景，例如缓存、计数器、实时消息等。

### 5.**JDK动态代理和Cglib代理的区别**

- JDK动态代理

  利用拦截器(拦截器必须实现InvocationHanlder)加上反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。

  JDK动态代理只能对实现了接口的类生成代理，而不能针对类。

- CGLIB动态代理

  利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

  CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的。

### 6.快排

从数列中挑出一个元素，称为 “基准”（pivot）；

重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 7.哈夫曼树

- 概念

  当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

- 对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

  1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
  2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
  3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

### 8.常用map底层原理

- hashmap底层实现

  - HashMap实现采用Entry数组来存储key-value对（数组默认大小为16），每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体，依次来解决Hash冲突的问题，因为HashMap是按照Key的hash值来计算Entry在HashMap中存储的位置的，如果hash值相同，而key内容不相等，那么就用链表来解决这种hash冲突。

  - 在Jdk1.8中HashMap的实现方式做了一些改变，但是基本思想还是没有变得，只是在一些地方做了优化，数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，j是在hash值相同的情况下（且重复数量大于8），用红黑树来管理数据。 红黑树相当于排序数据。可以自动的使用二分法进行定位(log n)。性能较高。

    [参考](http://www.52xingchen.cn/detail/49)

- ConcurrentHashMap的实现

  [参考](https://blog.csdn.net/weixin_44296929/article/details/108844926)

### 9.图

- 概念

  图是由顶点和边组成的一种数据结构，我们之前介绍的[树形结构](https://so.csdn.net/so/search?q=树形结构&spm=1001.2101.3001.7020)中，树的每一个节点就是顶点，顶点与顶点中的连线就是边，也就是说，树是一种特殊的图

  图中的边如果有方向，那么这个图就称为[有向图](https://so.csdn.net/so/search?q=有向图&spm=1001.2101.3001.7020)，反之则成为无向图

### 10.IO流

1、节点流：FileInputStream、FileOutputStream、FileReader、FileWriter

2、缓冲流：BufferedInputStream、FileOutputStream、BufferedReader、BufferedWriter

3、转换流：InputStreamReader、OutputStreamWriter，这种流的作用是将字节流转为字符流，提高IO流的效率。FileReader继承了InputStreamReader，当使用FileReader时，实际上在使用InputStreamReader按照字符的方式从磁盘读入数据到内存。

4、标准输入输出流：System.in、System.out

5、打印流：

6、数据流：PrintReader、PrintWriter

7、对象流：DataInputStream、DataOutputStream

8、随机存取流：RandomAccessFile，可以指定位置任意读取文本中的数据

### 11.三次握手，四次挥手

TCP 三次握手和四次挥手是 TCP 协议中建立和终止连接的过程。



三次握手的流程如下：

1. 客户端向服务器发送 SYN 包，表示请求建立连接，此时客户端进入 SYN_SENT 状态。
2. 服务器接收到 SYN 包后，回应一个 SYN-ACK 包，表示同意建立连接，此时服务器进入 SYN-RECEIVED 状态。
3. 客户端接收到 SYN-ACK 包后，向服务器回应一个 ACK 包，表示确认建立连接，此时客户端进入 ESTABLISHED 状态。服务器收到 ACK 包后也进入 ESTABLISHED 状态。



四次挥手的流程如下：

1. 客户端向服务器发送 FIN 包，表示希望关闭连接，此时客户端进入 FIN-WAIT-1 状态。
2. 服务器接收到 FIN 包后，向客户端回应一个 ACK 包，表示已经收到了关闭请求，此时服务器进入 CLOSE-WAIT 状态，客户端收到 ACK 包后进入 FIN-WAIT-2 状态。
3. 服务器关闭连接后，向客户端发送一个 FIN 包，表示可以关闭连接，此时服务器进入 LAST-ACK 状态。
4. 客户端接收到服务器的 FIN 包后，向服务器回应一个 ACK 包，表示已经收到关闭请求，此时客户端进入 TIME-WAIT 状态，等待 2MSL（最大报文生存时间）后，关闭连接。服务器收到 ACK 包后也进入 CLOSED 状态。

三次握手是为了确保客户端和服务器都能够收到对方的请求和回应，防止因为网络原因导致请求或回应丢失而建立不了连接。四次挥手则是为了确保连接的正常关闭，防止因为网络原因导致连接无法关闭或者出现连接断开后还能够接收到数据的情况。

### 12.cookie和session的区别

#### 1、对象不同

**cookie**：是针对每个网站的信息，每个网站只能对应一个，其他网站无法访问，这个文件保存在客户端，每次您拨打相应网站，浏览器都会查找该网站的 cookies，如果有，则会将该文件发送出去。cookies文件的内容大致上包括了诸如用户名、密码、设置等信息。

**session**：是针对每个用户的，只有客户端才能访问，程序为该客户添加一个 session。session中主要保存用户的登录信息、操作信息等等。此 session将在用户访问结束后自动消失(如果也是超时)。

#### 2、存储数据大小不同

**cookie**：一个 cookie存储的数据不超过3K。

**session**：session存储在服务器上可以任意存储数据。当 session存储数据太多时，服务器可选择进行清理。

#### 3、生命周期不同

**cookie**：cookie的生命周期当浏览器关闭的时候就消亡了，cookie的生命周期是累计的，从创建时就开始计时，30min后cookie生命周期结束。

**session**：session的生命周期是间隔的，从创建时开始计时如在30min内没有访问session，那么session生命周期就被销毁。

#### 4、存储位置不同

**cookie**：cookie数据保存在客户端。

**session**：session数据保存在服务器端。

#### 5、数据类型不同

两者都是key-value结构，但针对value的类型是有差异的。

**cookie**：value只能是字符串类型。

**session**：value是object类型。

#### 6、安全性不同

cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用session。
