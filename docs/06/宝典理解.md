### 第一章:Java基础

#### 1.1 面向对象的三个基本特征

- 面向对象的三个基本特征是:封装,继承,多态.

- 继承

  让某个类型的对象获得另一个类型的对象的属性和方法.

  继承就是子类继承父类的特征和行为,使得子类对象(实例)具有父类的实例域和方法,或子类从父类继承方法,是的子类继承父类相同的行为.

- 封装

  把数据和操作数据的方法打包到一个单元或对象中.

  隐藏不分对象的属性和实现细节,对数据的访问只能通过公开的接口。通过这种方式,对象对内部数据提供了不同级别的保护,以防止程序中无关的部分意外地改变和错误的使用了对象的私有部分.

- 多态

  对于同一个行为,不同的子类对象具有不同的表现形式.多态存在的三个条件: 1)继承；2)重写; 3)父类引用指向子类对象.

  同一个事件发生在不同对象上会产生不同的结果.
  
  

#### 1.2 修饰符

![img](img/修饰符.png)

#### 1.3类型转换问题

#### 1.3.1 精度丢失

```java
//代码块1
short s1=1;s1=s1+1;
//代码块2
short s2=1;s2+=1;
```

结果: 

代码块1编译报错,错误的原因是:不兼容的类型,从int转换到short可能会有损失.

代码块2正常运行.



#### 1.3.3 类型区间越界

```java
public static void main(String args[]){
    Integer a=128,b=128,c=127,d=127;
    System.out.println(a==b);
    System.out.println(c==d);
}

//结果为 false true


```

执行interger a=128，相当于执行:Interger a= Integer.valueOf(128)，基本类型自动转换为包装类型的过程成为自动装箱(autoboxing).

在Integer中引入了IntegerIntegerCache来缓存一定范围的值,IntegerCache默认情况下范围为-128-127。



#### 1.4 位运算符

高效计算2*8

答:2<<3.（左移相当于乘以2的几次幂n<<m相当于n乘以2的m次幂）

解释:通常情况下,可以认为位运算是性能最高的.



#### 1.5 &&和&

- &&:逻辑运算符.当运算符两边同时为true才返回true.同时具有短路性,如果第一个表达式为false，则直接返回false。

- **生活例子**:**串联**

- &:逻辑与运算符,按位与运算符

- 例:**用于二进制的计算**,只有对应的两个二进位均为1结果才为1,否则为0

- 区别:

  &在用于逻辑与时只有对应的两个二进位均为1时,结果才为1,否则都为0.

  &&:&和&&区别在于,&不具有短路性.



#### 1.6 基本数据类型(四类八种)

- 四类八种：整数类（byte、short、int、long）、浮点类（float、double）、字符类（char）、布尔型（boolean）；

  除此之外即为引用类数据类型。

- String不可被final修饰，因此不可以被继承



#### 1.7 String,StringBuffer和StringBuilder的区别

##### 1.7.1 简介

String:字符串类,适用于少量的字符串操作

StringBuilder:字符串缓冲类,适用于单线程下在字符缓冲刘进行大量操作,使用synchronized保证线程安全

StringBuffer:字符串缓冲流,适用于多线程下在字符串缓冲流进行大量操作,没有使用synchronized,具有更高的性能,推荐优先使用

##### 1.7.2 区别

1. String是final类不能被继承且为字符串常量，当进行字符串操作时地址即发生改变

   而StringBuilder和StringBuffer均为字符串变量.当使用append()操作时,内存地址不发生变化

2. 在String类中使用 "+" 作为数据的连接操作,而在StringBuffer类中使用append()方法.

3. String类和StringBuilder、StringBuffer类的转换。

   - String类通过apend()方法转换成StringBuilder和StringBuffer类。
   - StringBuffer类和StringBuilder类通过to.String()方法转换成String类型



#### 1.8 String s =new String("xyz")创建了几个字符串对象？

一个或者两个。如果字符串常量池已经有“xyz”,则是一个,否则两个



#### 1.9 ==和equals的区别

- ==  :运算符,用于比较基础类型和引用类型变量

  - 对于基础类型的变量,比较的变量保存的值是否相同,类型不一定要相同
  - 对于引用类型变量,比较的是两个的地址是否相同

- equals :Object类中定义的方法,通常用于比较两个对象的值是否相等

  ```java
  Integer i1=new Integer(1);
  Integer i2=new Integer(1);
  System.out.println(i1.equals(i2));
  //结果:true 两个不同的对象,但是具有相同的值
  ```

  



#### 1.10 hashCode()和equals()

- hashCode():哈希码并不是完全唯一的，它是一种[算法](https://links.jianshu.com/go?to=http%3A%2F%2Flib.csdn.net%2Fbase%2Fdatastructure)，让**同一个类的对象**按照自己不同的特征尽量的有不同的哈希码，但不表示不同的对象哈希码完全不同。也有相同的情况，看程序员如何写哈希码的算法。

- equals是Object类提供的方法之一。每一个Java类都集成自Object类，所以每一个对象都具有equals这个方法。Object类中定义的equals(Object)方法的情况下，equals(Object)与“==”运算符一样，比较的是引用.

  equals(Object)方法的特殊之处就在于它可以被覆盖，所以可以通过覆盖的方法让它不是比较引用而是比较数据内容，例如String类的equals方法是用于比较两个独立对象的内容是否相同，即堆中的内容是否相同。

  ```java
      String s1 = new String("Hello");
      String s2 = new String("Hello");
  
  /*两条new语句创建了两个对象，然后用s1、s2这两个变量分别指向一个对象，这是两个不同的对象，它们的首地址是不同的，即s1和s2中存储的数值是不相同的，所以，表达式s1==s2将返回false，而这两个对象中的内容是相同的，所以，表达式s1.equals(s2)将返回true。*/
  
  
  ```

- 1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
   2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。

- 结论

   两个对象的hasCode()相同,则equals()也不一定为true。


#### 1.11 反射

- 反射

  反射是指在运行状态中，对于任意一和类都能知道这个所有的属性和方法,并且对人一个对象,都能调用他的任意一个方法;这种动态获取信息以及动态调用对象方法的功能成为反射机制.

  反射涉及到四个核心类

  - java.lang.**Class.java**：类对象；
  - java.lang.reflect.**Constructor.java**：类的构造器对象；
  - java.lang.reflect.**Method.java**：类的方法对象；
  - java.lang.reflect.**Field.java**：类的属性对象；

- 作用

  - 操作因5访问权限限制的属性和方法;
  - 实现自定义注解;
  - 动态加载第三方jar包;
  - 按需加载类,节省编译和初始化APK时间.

- 工作原理

  当我们编写完一个Java项目之后，每个java文件都会被编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被ClassLoader加载到虚拟机中。当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是不透明的而已。
  
  反射的工作原理就是借助Class.java、Constructor.java、Method.java、Field.java这四个类在程序运行时动态访问和修改任何类的行为和状态。





### 拓展

#### 1.说出ArrayList,Vector,LinkedList的储存性能和特性

- ArrayList 和 Vector：底层原理都是用数组来实现的,对于此数组来说当数组元素数大于实际储存的数据时方便数据的插入和增加,他们都允许通过索引来查找元素,但是插入元素要设计元素移动等内存操作,所以他们的特点为索引数据快而插入数据慢.

- LinkedList : 底层原理使用双链表实现,按序号索引数据需要向前或者向后查找遍历,因此速度较慢,但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

  ```java
  //显示链表（遍历）
      public void show() {
          //判断链表是否为空
          if (head.next == null) {
              System.out.println("链表为空");
              return;
          }
          //因为head节点不能动，因此需要新建一个辅助变量temp
          HeroNode temp = head.next;
          while (true) {
              //判断是否到链表最后
              if (temp == null) {
                  break;
              }
              //输出节点信息
              System.out.println(temp);
              //将temp后移
              temp = temp.next;
          }
      }
      //主程序
       public static void main(String[] args) {
          HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
          HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
          HeroNode hero3 = new HeroNode(3,"吴用","智多星");
          HeroNode hero4 = new HeroNode(4,"林冲","豹子头");
          DoubleSingleLikedList singleLikedList = new DoubleSingleLikedList();
          singleLikedList.addLast(hero1);
          singleLikedList.addLast(hero2);
          singleLikedList.addLast(hero3);
          singleLikedList.addLast(hero4);
          System.out.println("====遍历链表信息====");
          singleLikedList.show();
      }
  
  ```

#### 2.内存泄露和内存溢出

1. 内存泄露:是指应用程序在申请内存后,无法释放已经申请的内存空间,一次内存泄露危害可以忽略,但是如果任其发展最终会导致内存溢出.
   - 如读取文件后流要进行及时的关闭以及数据库连接的释放.
   - 指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。
2. 内存溢出:是指程序在申请内存时,没有足够的内存空间供其使用.
   - 如程序申请了一个int类型大小的空间,但是储存了需要long类型空间大小才能存储的数,那就是内存溢出.
   - MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中.
